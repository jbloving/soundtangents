<!DOCTYPE html>
<html lang="en">

<head>
<style>


/* --- consolidated styles --- */
:root {
  --bg:#0f1724; --panel:#0b1220; --accent:#6ee7b7; --muted:#94a3b8; --cell:#102236; --cellOn:#4f46e5; --cellOn2:#7c3aed; --ui-accent-line: #0033ff;

  /* F08: Scale factor for responsive design */
  --sf: 1; /* scale factor - adjusts at breakpoints */

  /* F08: Major widths (multiply by --sf for responsive scaling) */
  --stepW: calc(84px * var(--sf)); /* G07: increased from 80px for better spacing */
  --stepGap: calc(15px * var(--sf)); /* G07: reduced from 18px for tighter layout */
  --stepStride: calc(99px * var(--sf)); /* G07: updated to match step + gap (84 + 15) */

  /* G18: 6-column explicit widths */
  /* H03: Increased base widths from 120px to 146px so they render at ~120px with sf=0.82 */
  /* (146 * 0.82 = 119.7px ≈ 120px) - columns scale independently of grid */
  --nameColW: calc(146px * var(--sf)); /* Name + sends */
  --sampColW: calc(146px * var(--sf)); /* Sample button + controls */
  --gridColW: auto; /* G25: changed from 1fr to auto - shrink-wrap steps content */
  --controlColW: calc(146px * var(--sf)); /* Legend/autofill */
  --adsrColW: calc(146px * var(--sf)); /* ADSR sliders only */
  --readoutColW: calc(50px * var(--sf)); /* H10: reduced from 55px to 50px - reclaim space for GridCol */

  /* H12: Removed legacy 4-column variables (--trackLeftW, --trackLegendW, --trackAdsrW) */

  /* G22: Standardized column gap */
  --trackGap: calc(15px * var(--sf)); /* G22: increased from 12px, uniform spacing between all columns */

  --hitSize: calc(48px * var(--sf));
  --uiRowW: calc(68px * var(--sf));

  /* H02: Unified slider width - all horizontal sliders use this for consistency */
  /* H03: Increased base from 108px to 132px so renders at ~108px with sf=0.82 */
  --sliderW: calc(132px * var(--sf)); /* 132 * 0.82 = 108px at 1920px viewport */
  --sendW: var(--sliderW); /* H02: was 100px, now unified */
  --adsrSliderW: var(--sliderW); /* H02: was 108px, now unified */
  --adsrRowMinW: var(--sliderW); /* H02: match slider width */
}
  * { box-sizing: border-box; }
  body{ background: linear-gradient(180deg,#071023 0%, #071827 100%); color:#e6eef8; font-family:Inter,system-ui,Arial; padding:0 18px 18px 18px;} /* B13: padding-top moved to .stickyHeader */
  h1{ margin:0 0 10px 0; font-weight:600; font-size:20px }
  /* B13: Sticky header wrapper for frozen top rows */
  .stickyHeader{
    position: sticky;
    top: 0;
    z-index: 2000;
    background: linear-gradient(180deg,#071023 0%, #071827 100%);
    box-shadow: 0 10px 24px rgba(0,0,0,0.25);
    padding-top: 18px;
    /* F12: Extend background to cover ADSR column when scrolling */
    margin-left: -18px;
    margin-right: -18px;
    padding-left: 18px;
    padding-right: 18px;
  }
  .top { display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap;}
  .fxrow { display:flex; gap:11px; align-items:flex-start; margin-bottom:9px; flex-wrap:wrap;} /* G11: increased from 5px to 9px to prevent btnrow overlap on laptop */
  /* Vertical FX modules (UI only) */
  .fxrow.fxbar{ display:inline-flex; width:max-content; flex-wrap:nowrap; gap:16px; padding-bottom:6px; } /* G11: increased from 3px to 6px */
  .panel { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.06); }
  .controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .controls input[type=range]{ width:140px; }
  .small { font-size:11px; color:var(--muted); }
  button { background:#0b2540; color:#d1fae5; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.08); cursor:pointer; }
  button.recording { background:#ef4444; color:white; box-shadow:0 6px 18px rgba(239,68,68,0.18); }

  /* I03/I04: Subtle manual and donate links in top right */
  .contactLink, .manualLink, .donateLink {
    color: var(--muted);
    opacity: 0.5;
    transition: opacity 0.2s ease;
    display: flex;
    align-items: center;
  }
  .contactLink { margin-left: auto; }
  .manualLink { margin-left: 8px; }
  .donateLink { margin-left: 8px; }
  .contactLink:hover, .manualLink:hover, .donateLink:hover { opacity: 0.9; }

  .grid { margin-top:12px; margin-left:8px; display:flex; flex-direction:column; gap:14px; max-width:1440px; } /* G16: default 8px, override to -7px at laptop sizes */
  /* H11: Removed old 4-column .track definition - replaced by 6-column grid in G22 section below */
  .leftCol { display:flex; gap:10px; }
  .nameAndSends { display:flex; flex-direction:column; gap:8px; min-width:100px;} /* G04: reduced from 110px */
  .sendCol { display:flex; flex-direction:column; gap:6px; }
  .sendBlock { display:flex; flex-direction:column; gap:4px; }
  .sendBlock .lab { font-size:11px; color:#9fb4d6; }
  .sendBlock input[type=range]{ width: var(--sendW); } /* F08: using CSS variable */

  .sampleCol { display:flex; flex-direction:column; gap:6px;  margin-bottom:10px; }
  .sampleCol .btnrow{ display:flex; gap:6px; align-items:center; flex-wrap:wrap }
  .sampleInfo{ font-size:10px; color:#9fb4d6; max-width:120px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; } /* G21: reduced from 220px to fit column */

  .steps { --rowColor: rgba(255,255,255,0.06); display:grid; grid-template-columns: repeat(16, var(--stepW)); gap: var(--stepGap); padding:12px 0; border-radius:10px; position:relative; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); outline:1px solid rgba(255,255,255,0.05); min-width:0; } /* G23: removed horizontal padding (14px) to eliminate gap after GridCol */
  /* Column guides aligned to cells + gap => stepStride (84px + 15px = 99px) */
  .steps::before{ content:""; position:absolute; inset:0; pointer-events:none; background:
    repeating-linear-gradient(to right, transparent 0 var(--stepStride), rgba(255,255,255,0.06) var(--stepStride) calc(var(--stepStride) + 1px)),
    linear-gradient(transparent, transparent); border-radius:10px; } /* F08: using CSS variable for stride */
  .step { display:grid; grid-template-rows: var(--hitSize) 29px 29px 29px 29px; gap:7px; justify-items:center; padding:7px 5px; background:rgba(255,255,255,0.02); border-radius:8px; border:1px solid var(--rowColor); } /* G06: restored original padding (vertical 7px, horizontal 5px) */
  .hit { width: var(--hitSize); height: var(--hitSize); border-radius:8px; background:var(--cell); border:1px solid rgba(255,255,255,0.05); cursor:pointer; } /* F08: using CSS variable */
  .hit.active{ background:linear-gradient(180deg,var(--cellOn),var(--cellOn2)); box-shadow:0 6px 18px rgba(124,58,237,0.18); }
  .hit.current{ outline:3px solid rgba(0, 255, 255, 0.20); transform: translateY(-1px); } /* B06: Subtle cyan cursor */

  .ui-row { width: var(--uiRowW); display:flex; flex-direction:column; align-items:center; gap:4px; } /* F08: using CSS variable */
  input[type=range]{ width: var(--uiRowW); -webkit-appearance:none; appearance:none; background:transparent; } /* F08: using CSS variable */
  input[type=range]::-webkit-slider-runnable-track{
  background:#ff6666; height:2px; background:#1f3b59; border-radius:2px; box-shadow: inset 0 0 0 2px var(--ui-accent-line); }
  input[type=range]::-webkit-slider-thumb{ -webkit-appearance:none; width:14px; height:14px; border-radius:50%; background:#e5e7eb; margin-top:-5px; border:2px solid #0033ff; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3); }
  input[type=range]::-moz-range-track{
  background:#ff6666; height:2px; background:#1f3b59; border-radius:2px; box-shadow: inset 0 0 0 2px var(--ui-accent-line); }
  input[type=range]::-moz-range-thumb{ width:14px; height:14px; border-radius:50%; background:#e5e7eb; border:2px solid #0033ff; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3); }
  select{ height:22px; font-size:12px; background:#0c223a; color:#e6eef8; border:1px solid rgba(255,255,255,0.12); border-radius:6px; padding:0 6px; }

  /* === Vertical FX modules (UI-only; audio untouched) === */
  .fxbar{ display:inline-flex; width:max-content; gap:16px; align-items:stretch; flex-wrap:nowrap; padding-bottom:6px; } /* B03: gap 18→16 */
  .fxModule{
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    width: max-content;
    min-width: max-content;
    padding: 13px 11px; /* B03: padding 14px 12px → 13px 11px */
    border: 1px solid #ff6666;
    border-radius: 8px;
    background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    box-shadow: 0 16px 34px rgba(0,0,0,0.22);
    position:relative;
    /* Firefox: clip rotated slider painting */
    flex-shrink: 0;
    transition: opacity 0.2s ease, border-color 0.2s ease;
  }
  .fxTitle:active {
    cursor: grabbing !important;
  }
  /* Connection dots */
  .fxConnectDot {
    position: absolute;
    right: -5px;
    top: 50%;
    transform: translateY(-50%);
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: 2px solid #ff6666;
    background: transparent;
    cursor: pointer;
    transition: all 0.2s ease;
    z-index: 10;
  }
  .fxConnectDot:hover {
    border-color: #ff8888;
    transform: translateY(-50%) scale(1.2);
  }
  .fxConnectDot.connected {
    background: #ff6666;
    border-color: #ff6666;
    box-shadow: 0 0 8px rgba(255, 102, 102, 0.6);
  }
  /* Connection line (SVG overlay) */
  .fxConnectionLine {
    stroke: #ff6666;
    stroke-width: 2;
    fill: none;
    pointer-events: none;
  }
  /* Typography pass (Stage 2): keep the same style, but restore sane hierarchy */
  .fxTitle{ text-align:center; font-size:16px; line-height:1.05; font-weight:400; letter-spacing:0px; margin:6px 0 10px; color:#e6eef8; } /* B03: font-size unchanged */
  .vfaders{ height:216px; display:flex; gap:16px; align-items:flex-end; justify-content:flex-start; padding: 7px 5px 0; } /* B03: 240→216, gap 18→16, padding 8px 6px→7px 5px */
  .fxFaders{ display:grid; grid-auto-flow:column; grid-auto-columns:50px; gap:13px; align-items:end; justify-content:start; width:fit-content; } /* B03: 56→50, gap 14→13 */
  .vfader{ width:50px; display:flex; flex-direction:column; align-items:center; justify-content:flex-end; gap:7px; overflow:visible; } /* B03: width 56→50, gap 8→7 */
  .vfader .lab, .vfader .fxLab{ font-size:11px; color:#9fb4d6; font-weight:500; letter-spacing:0.04em; white-space:nowrap; } /* B03: font-size unchanged */
  .fxVal{ font-size:10px; color:rgba(255,255,255,0.65); font-weight:600; margin-top:4px; }


/* vertical slider: robust rotation-based vertical fader (UI only) */
.vfader .vctrl{
  width:36px; height:207px; /* B03: 40→36, 230→207 */
  position:relative;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden; /* prevents rotated range from painting outside in Firefox */
}
.vfader input[type=range]{
  width:189px; height:18px; /* B03: 210→189, 20→18 */
  -webkit-appearance:none;
  appearance:none;
  background:transparent;
  /* Use a single transform for better Firefox compatibility */
  transform: translate(-50%, -50%) rotate(-90deg);
  transform-origin:center;
  position:absolute;
  left:50%; top:50%;
}

/* H15: Removed deprecated Firefox @supports(-moz-appearance:slider-vertical) block
   Firefox no longer supports this value, so the block never matched anyway.
   Firefox now uses the same rotated slider approach as other browsers. */

.vfader input[type=range]::-webkit-slider-runnable-track{
  background:#ff6666;
  height:2px; width:100%;
  background:#1f3b59;
  border-radius:2px;
  box-shadow: inset 0 0 0 2px var(--ui-accent-line);
}
.vfader input[type=range]::-webkit-slider-thumb{
  -webkit-appearance:none;
  width:14px; height:14px;  /* match horizontal slider thumb */
  border-radius:50%;
  background:#ffffff;
  border:2px solid #0033ff;
  box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
  margin-top:-6px; /* center thumb on 2px track */
}
.vfader input[type=range]::-moz-range-track{
  background:#ff6666;
  height:2px; width:100%;
  background:#1f3b59;
  border-radius:2px;
  box-shadow: inset 0 0 0 2px var(--ui-accent-line);
}
.vfader input[type=range]::-moz-range-thumb{
  width:14px; height:14px;  /* match horizontal slider thumb */
  border-radius:50%;
  background:#ffffff;
  border:2px solid #0033ff;
  box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
}
.vfader input[type=range]::-moz-range-progress{ background:transparent; }

  .fxFooter{ margin-top:10px; display:flex; justify-content:center; gap:10px; align-items:center; }
  .fxFooter .small{ font-size:12px; color:rgba(255,255,255,0.80); }
  .fxFooter select{ height:26px; font-size:12px; }
  /* F18: Reverse Ghost Clock dropdown (in footer like Maja) */
  #ghostClockFooter.inactive {
    opacity: 0.3;
    pointer-events: none;
  }
  .fxToggle{ display:flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.10); background:rgba(0,0,0,0.10); }
  .fxToggle input{ accent-color:#0033ff; }

  /* H13: Moved .legend definition to 6-column grid section (consolidated) */
  .legend .row{ display:flex; align-items:center; font-size:12px; gap:7px; } /* B04: gap 6→7px, font-size unchanged */
  .legend .row span{ flex: 0 0 auto; }
  .legend .row select{ width:86px; }

  /* H13: Removed old .adsr horizontal layout (lines 266-268) - superseded by vertical layout at line 275 */
  .rowTitle{ font-weight:600; color:#cfe3ff; margin-bottom:6px; }
  /* F09: Removed conflicting media query - now using CSS variables with --sf */

/* === UI1: ADSR vertical column (UI only) === */
/* H01: Removed old 4-column .track definition (conflicted with 6-column grid at line 308) */
/* H01: Removed old .legend{ grid-area: legend; } (now uses grid-area: control in consolidated section) */
.adsr{ grid-area: adsr; display:flex; flex-direction:column; gap:10px; padding-left:12px; } /* B04: gap 8→10px, padding 10→12px */
.adsr .row{ display:flex; flex-direction:column; align-items:flex-start; gap:4px; } /* E07: vertical layout - tag above slider */
.adsr .tag{ width: var(--adsrSliderW); text-align:center; color:#cfe3ff; } /* F08: using CSS variable */
.adsr .row .sliderRow{ display:flex; flex-direction:row; align-items:center; gap:3px; min-width: var(--adsrRowMinW); } /* F16: reduced gap from 4px to 3px for tighter spacing */
.adsr input[type=range]{ width: var(--adsrSliderW); } /* F08: using CSS variable */
/* E03: ADSR readouts for Silencer - show constrained ms/depth values */
.adsrReadout{
  min-width: calc(45px * var(--sf)); /* G02: Scale with viewport */
  text-align: right;
  color: #94a3b8;
  font-size: 11px;
  font-family: Inter,system-ui,Arial; /* E09: match page font style */
}
/* F09: Removed conflicting single-column media query - now using proportional scaling */

/* === UI2b: remove step tick lines (UI only) === */
.steps::before{ content: none !important; display:none !important; }


/* === UI3b: Unclamp grid/container width (UI only) === */
.grid{ max-width: none !important; width: 100% !important; align-items: stretch; }
.container{ max-width: none !important; width: 100% !important; }
.track{ width: 100%; }


/* ======================================================================= */
/* === G22: 6-COLUMN GRID LAYOUT - ALL COLUMN CSS CONSOLIDATED HERE === */
/* ======================================================================= */

/* Main track grid: 6 explicit columns */
.track{
  display: grid !important;
  grid-template-columns: var(--nameColW) var(--sampColW) var(--gridColW) var(--controlColW) var(--adsrColW) var(--readoutColW) !important;
  grid-template-areas: "name samp grid control adsr readout" !important;
  align-items: start !important;
  justify-content: start !important; /* H01: Pack all columns to the left, no extra space distribution */
  column-gap: var(--trackGap) !important; /* G22: uniform 15px gap between all columns */
}

/* Column 1: Name + Sends */
.nameAndSends{
  grid-area: name;
  overflow: hidden;
}

/* Column 2: Sample Controls */
.sampleCol{
  grid-area: samp;
  overflow: visible; /* H07: Changed from hidden to allow solo glow to show */
}

/* Column 3: Grid (16 steps) */
.steps{
  grid-area: grid;
  display: grid !important;
  grid-template-columns: repeat(16, var(--stepW, 76px)) !important;
  gap: var(--stepGap, 12px) !important;
  min-width: 0 !important; /* Allow compression */
  justify-self: start !important; /* Left-aligned in cell */
  padding: 12px 0 !important; /* Vertical padding only */
}

/* Column 4: Control (Legend/Autofill) - H13: consolidated from two definitions */
.legend{
  grid-area: control;
  width: var(--controlColW) !important;
  min-width: var(--controlColW) !important;
  overflow: hidden;
  display: grid;
  grid-template-rows: var(--hitSize) 29px 29px 29px 29px; /* H09: var(--hitSize) scales with viewport */
  align-content: start;
  gap: 7px;
  padding: 19px 10px 7px;
  border-left: 1px dashed rgba(255,255,255,0.08);
  color: var(--muted);
}

/* Column 5: ADSR Sliders */
.adsrSliders{
  grid-area: adsr;
  display:flex;
  flex-direction:column;
  gap:10px;
  overflow: hidden;
}
.adsrSliders .row{
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  gap:4px;
}
.adsrSliders .tag{
  width: var(--adsrSliderW);
  text-align:center;
  color:#cfe3ff;
}
.adsrSliders .row .sliderRow{
  display:flex;
  flex-direction:row;
  align-items:center;
  gap:3px;
  min-width: var(--adsrRowMinW);
}
.adsrSliders input[type=range]{
  width: var(--adsrSliderW);
}

/* Column 6: ADSR Readout (Silencer only) */
.adsrReadout{
  grid-area: readout;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.adsrReadout .row{
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  gap:4px;
  /* H05: Match slider row height - tag (~16px) + gap (4px) + slider (~20px) = ~40px */
  min-height: 40px;
  justify-content:center; /* H06: Center readout vertically in row */
}
.adsrReadout .readoutValue{
  min-width: calc(45px * var(--sf));
  text-align: right;
  color: #94a3b8;
  font-size: 11px;
  font-family: Inter,system-ui,Arial;
}

/* ======================================================================= */
/* === END OF 6-COLUMN GRID LAYOUT === */
/* ======================================================================= */


/* === H12: Tone dial styles (consolidated from UI4b/UI4c/3i1e/3i1d) === */
.toneDial{
  position: relative; width: 44px; height: 44px; border-radius: 50%;
  background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  border: 1px solid rgba(255,255,255,0.14);
  box-shadow: 0 0 0 1px var(--ui-accent-line);
  display:flex; align-items:center; justify-content:center;
  user-select:none; touch-action: none;
}
.toneNeedle{
  position:absolute; left:50%; top:50%;
  width:2px; height:18px; background:#e6eef8; border-radius:1px; opacity:.9;
  transform-origin:50% 100%;
  transform:translate(-50%,-100%) rotate(var(--deg,0deg));
}
.toneWrap{ display:flex; align-items:center; gap:10px; }
.toneDialCol{ display:flex; flex-direction:column; align-items:center; gap:4px; width:72px; min-width:72px; } /* 3i1e: fixed width prevents jitter */
.toneReadout{ font-size:11px; color:#9fb4d6; text-align:center; min-width:auto; opacity:.9; white-space:nowrap; }


/* === Phase 4: per-track length rail === */
.steps, .stepsCol { position: relative; }
.lenRail{ position:absolute; left:0; right:0; top:-10px; height:12px; pointer-events:auto; z-index:5; }
.lenRailLine{ position:absolute; left:0; right:0; top:6px; height:2px; background:#ff6666; opacity:0.9; }
.lenRailMarker{ position:absolute; top:0; width:0; height:0; border-left:8px solid transparent; border-right:8px solid transparent; border-top:10px solid #ff6666; transform:translateX(-50%); }
.lenRailGrab{ position:absolute; left:0; right:0; top:0; bottom:0; cursor:ew-resize; }
.step.dim{ opacity:0.35; }

/* Phase 4: shade to the right of the marker */
.lenShade{ position:absolute; top:0; right:0; bottom:0; left:100%; background: rgba(255,255,255,0.08); pointer-events:none; z-index:1; border-radius:8px; }



/* CR-051: add right spacing on effects sliders */
.panel .controls input[type="range"] { margin-right: 20px; }





/* H14: Removed dead #pitchControls CSS (CR-052) - element doesn't exist in HTML */




/* === Phase 7: Scenes bar (UI-only) === */
.scenesBar { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.06); padding:8px 10px; border-radius:10px; }
.scenesBar .sceneBtn, .scenesBar .sceneNav, .scenesBar .sceneAdd, .scenesBar .chainBtn{
  width:44px; height:44px; border-radius:12px; background:#0b2540; color:#e6eef8;
  border:1px solid rgba(255,255,255,0.08); font-size:18px; display:inline-flex; align-items:center; justify-content:center;
  box-shadow: inset 0 0 0 2px rgba(255,255,255,0.04);
}
.scenesBar .sceneBtn.inactive { opacity:0.35; pointer-events:none; }
.scenesBar .sceneBtn.active { background:rgba(255, 102, 102, 0.5); } /* B07: Red background fill at 50% for current viewing page */
#sceneAdd { margin-left: 40px; } /* G06: Add spacing between → and + */

/* Chain button icon + inactive/active states */
.chainBtn{ font-size:0; opacity:0.35; margin-left:15px; position:relative; }
.chainBtn.active{ opacity:1; border-color:rgba(255,255,255,0.25); box-shadow:0 6px 18px rgba(124,58,237,0.18); }
.chainBtn::before{
  content:""; width:22px; height:22px; display:inline-block; background:currentColor;
  mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="white" d="M10.59 13.41c.78.78 2.05.78 2.83 0l2.83-2.83a2 2 0 0 0 0-2.83 2 2 0 0 0-2.83 0l-.71.71-1.41-1.41.71-.71a4 4 0 0 1 5.66 5.66l-2.83 2.83a4 4 0 0 1-5.66 0l-.71-.71 1.41-1.41.71.71zM7.76 16.24a2 2 0 0 0 2.83 0l.71-.71 1.41 1.41-.71.71a4 4 0 1 1-5.66-5.66l2.83-2.83a4 4 0 0 1 5.66 0l.71.71-1.41 1.41-.71-.71a2 2 0 0 0-2.83 0l-2.83 2.83a2 2 0 0 0 0 2.83z"/></svg>');
  -webkit-mask: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill=\"white\" d=\"M10.59 13.41c.78.78 2.05.78 2.83 0l2.83-2.83a2 2 0 0 0 0-2.83 2 2 0 0 0-2.83 0l-.71.71-1.41-1.41.71-.71a4 4 0 0 1 5.66 5.66l-2.83 2.83a4 4 0 0 1-5.66 0l-.71-.71 1.41-1.41.71.71zM7.76 16.24a2 2 0 0 0 2.83 0l.71-.71 1.41 1.41-.71.71a4 4 0 1 1-5.66-5.66l2.83-2.83a4 4 0 0 1 5.66 0l.71.71-1.41 1.41-.71-.71a2 2 0 0 0 2.83 0l-2.83 2.83a2 2 0 0 0 0 2.83z\"/></svg>');
}

/* B06: Subtle cyan cursor highlight */
.hit.current{ outline:3px solid rgba(0, 255, 255, 0.20); transform: translateY(-1px); }

.scenesBar .sceneBtn.playing { outline:2px solid rgba(0, 255, 255, 0.40); box-shadow:0 0 0 2px rgba(0, 255, 255, 0.16) inset; } /* B08: Brighter cyan playing page indicator at 40% */



/* H02: All track sliders use unified --sliderW for consistency */
.pitchSlider{ width: var(--sliderW); }
.trackSlider{ width: var(--sliderW); } /* H02: class for JS-created sliders (Vol, Pan, Tone) */

.tilt-slider-wrapper {
  position: relative;
  display: inline-block;
}
.tilt-slider-wrapper .tilt-center-line {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 2px;
  height: 70%;
  background: rgba(255,255,255,0.85);
  pointer-events: none;
  border-radius: 1px;
}


/* === B16: Remove ADSR column for Phrase sampler row (UI only) === */
/* G18: Hide ADSR and readout columns for Phrases track */
.track.noAdsr{
  grid-template-columns: var(--nameColW) var(--sampColW) var(--gridColW) var(--controlColW) 0 0 !important;
  grid-template-areas: "name samp grid control . ." !important;
}
.track.noAdsr .adsrSliders,
.track.noAdsr .adsrReadout {
  display:none !important;
}

/* === F08: Responsive scaling via --sf (scale factor) === */
/* F11: Adjusted breakpoints to trigger at realistic viewport widths */
/* F19: Added 2200px breakpoint for Mac laptops */
/* G01: Added 1800px breakpoint for smaller Mac laptop windows */
/* G08: Recalculated scale factors to fit new step dimensions (84px/15px) */
/* G10: More aggressive scaling for better fit */
@media (max-width: 2200px) {
  :root { --sf: 0.93; } /* G10: reduced from 0.95 */
}

@media (max-width: 1920px) {
  :root { --sf: 0.82; } /* H03: reverted from 0.86 - sf scales grid too, causing bleed */
}

@media (max-width: 1800px) {
  :root { --sf: 0.73; } /* H08: reverted to 0.73 - user prefers larger grid steps */
}

@media (max-width: 1600px) {
  :root { --sf: 0.68; } /* G10: reduced from 0.70 */
}

@media (max-width: 1550px) {
  :root { --sf: 0.64; } /* I03: for ~1536px viewport (1760px screen with Windows scaling) */
}

@media (max-width: 1400px) {
  :root { --sf: 0.62; } /* G10: reduced from 0.64 */
}

@media (max-width: 1200px) {
  :root { --sf: 0.56; } /* G10: reduced from 0.58 */
}

/* G03: Scale effects bar using transform for smaller screens */
/* G10: Less aggressive transform on effects for more width */
@media (max-width: 1920px) {
  .fxbar, .fxrow.fxbar {
    transform: scale(0.90); /* G10: increased from 0.84 to give effects more room */
    transform-origin: left top;
  }
}

@media (max-width: 1800px) {
  .fxbar, .fxrow.fxbar {
    transform: scale(0.82); /* G10: increased from 0.75 to give effects more room */
    transform-origin: left top;
  }

  /* G16: Apply negative margin only at laptop sizes to prevent overlap */
  .grid {
    margin-left: -7px;
  }

  /* H10: Reduce body side padding on laptop for more canvas width */
  body {
    padding-left: 10px;
    padding-right: 10px;
  }
  .stickyHeader {
    margin-left: -10px;
    margin-right: -10px;
    padding-left: 10px;
    padding-right: 10px;
  }
}

@media (max-width: 1550px) {
  .fxbar, .fxrow.fxbar {
    transform: scale(0.75); /* I03: for ~1536px viewport (Windows scaled) */
    transform-origin: left top;
  }
}

/* H09: Removed debug visualization (G17/G18 color backgrounds and width indicators) */

/* Browser compatibility overlay */
#compat-overlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,.72);
  display: none;
  align-items: center; justify-content: center;
  z-index: 999999;
  padding: 16px;
}
#compat-card {
  max-width: 640px; width: 100%;
  background: #111; color: #fff;
  border: 1px solid rgba(255,255,255,.15);
  border-radius: 14px;
  padding: 18px 18px 14px;
  box-shadow: 0 10px 40px rgba(0,0,0,.5);
  font: 15px/1.4 -apple-system, system-ui, Segoe UI, Roboto, sans-serif;
}
#compat-card h2 { margin: 0 0 10px; font-size: 18px; }
#compat-card p { margin: 0 0 10px; opacity: .92; }
#compat-card ul { margin: 8px 0 12px 18px; opacity: .92; }
#compat-actions { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
.compat-btn {
  appearance: none; border: 0; cursor: pointer;
  padding: 10px 12px; border-radius: 10px;
  font-weight: 600;
}
.compat-primary { background: #2f7cff; color: #fff; }
.compat-secondary { background: rgba(255,255,255,.12); color: #fff; }
#compat-small { font-size: 12px; opacity: .7; margin-top: 10px; }

</style>

<meta charset="utf-8" />

<meta name="viewport" content="width=device-width,initial-scale=1" />










<!-- DIAG: capture scheduler/UI state (non-invasive) -->


</head>
<body tabindex="0">

  <!-- Browser compatibility warning -->
  <div id="compat-overlay" role="dialog" aria-modal="true" aria-labelledby="compat-title">
    <div id="compat-card">
      <h2 id="compat-title">Compatibility notice</h2>
      <div id="compat-body"></div>
      <div id="compat-actions">
        <button class="compat-btn compat-primary" id="compat-continue" type="button">I understand</button>
      </div>
      <div id="compat-small">
        I'm actively improving compatibility. Audio apps behave differently across browsers.
      </div>
    </div>
  </div>

  <!-- H09: Removed debug counter display (A3) -->

  <!-- B13: Sticky wrapper for frozen header rows -->
  <div class="stickyHeader">

  <!-- Row 1: Start + Tempo -->
  <div class="top">
    <div class="panel controls">
      <button id="startStop" title="Space bar also toggles">Start</button>
      <div class="small">Tempo</div>
      <input id="tempo" type="range" min="60" max="200" value="120">
      <div id="tempoVal" class="small">120 BPM</div>
      <button id="clear">Clear Grid</button>
      <button id="recordBtn">Record WAV</button>
      <a id="downloadLink" style="display:none;margin-left:8px;color:var(--accent)"></a>
    </div>

    <!-- Harmonic Framework Panel -->
    <div class="panel controls">
      <label class="small">Key:</label>
      <select id="globalRoot">
        <option value="0">C</option>
        <option value="1">C#</option>
        <option value="2">D</option>
        <option value="3">D#</option>
        <option value="4">E</option>
        <option value="5">F</option>
        <option value="6">F#</option>
        <option value="7">G</option>
        <option value="8">G#</option>
        <option value="9">A</option>
        <option value="10">A#</option>
        <option value="11">B</option>
      </select>
      <label class="small" style="margin-left:10px;">Scale:</label>
      <select id="globalScale">
        <option value="chromatic">Chromatic</option>
        <option value="major">Major</option>
        <option value="minor">Minor</option>
        <option value="pentatonicMajor">Pentatonic Major</option>
        <option value="pentatonicMinor">Pentatonic Minor</option>
      </select>
    </div>

    <!-- B01: Scenes Bar moved to top container -->
    <div class="panel scenesBar" id="scenesBar" style="margin-left:30px; display:flex; gap:12px; align-items:center; justify-content:flex-start;">
      <button class="sceneNav" id="scenePrev" title="Previous page (←)">←</button>
      <button class="sceneBtn" id="sceneBtn1" data-pg="0">1</button>
      <button class="sceneBtn" id="sceneBtn2" data-pg="1">2</button>
      <button class="sceneBtn" id="sceneBtn3" data-pg="2">3</button>
      <button class="sceneBtn" id="sceneBtn4" data-pg="3">4</button>
      <button class="sceneNav" id="sceneNext" title="Next page (→)">→</button>
      <button class="sceneAdd" id="sceneAdd" title="Add page (+)">+</button>
      <button class="sceneAdd" id="sceneRemove" title="Remove current page (-)">−</button>
      <button class="chainBtn" id="chainBtn" title="Chain pages (toggle)"></button>
    </div>

    <!-- I06: Contact link - envelope icon -->
    <a href="mailto:dumbaroma@gmail.com" class="contactLink" title="Contact / Report Bug">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <rect x="2" y="4" width="20" height="16" rx="2"/>
        <path d="M22 7l-10 7L2 7"/>
      </svg>
    </a>
    <!-- I03: Manual link - subtle book icon -->
    <a href="https://soundtangents.com/manual.pdf" target="_blank" download class="manualLink" title="Download Manual">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
      </svg>
    </a>
    <!-- I04: Donate link -->
    <a href="https://www.paypal.com/donate/?hosted_button_id=STFFYU5PCY8FE" target="_blank" class="donateLink" title="Donate">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <line x1="12" y1="1" x2="12" y2="23"/>
        <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/>
      </svg>
    </a>
  </div>

  <!-- Row 2: FX Panels -->
  <div class="fxrow fxbar">

    <!-- Maja (vertical module UI only; audio unchanged) -->
    <div class="fxModule" aria-label="Maja" data-effect="maja">
      <div class="fxTitle" draggable="true" style="cursor: grab;">Maja</div>
      <div class="fxFaders">
        <div class="vfader">
          <div class="vctrl"><input id="majaTilt" type="range" min="-1" max="1" step="0.01" value="0"></div>
          <div class="fxLab">Tilt</div>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="majaDrive" type="range" min="0" max="1" step="0.01" value="0.2"></div>
          <div class="fxLab">Drive</div>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="majaAir" type="range" min="0" max="6" step="0.1" value="2"></div>
          <div class="fxLab">Spread</div>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="majaLfoRate" type="range" min="0.05" max="12" step="0.01" value="0.8"></div>
          <div class="fxLab">LFO Rate</div>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="majaLfoDepth" type="range" min="0" max="1" step="0.01" value="0.6"></div>
          <div class="fxLab">LFO Depth</div>
        </div>
      </div>
      <div class="fxFooter">
        <span class="small">LFO Target</span>
        <select id="majaLfoTarget">
          <option value="cutoff">Cutoff</option>
          <option value="wet">Wet</option>
        </select>
      </div>
    </div>

    <!-- Dub -->
    <div class="fxModule" aria-label="Dub" data-effect="dub">
      <div class="fxTitle" draggable="true" style="cursor: grab;">Dub</div>
      <div class="fxFaders">
        <div class="vfader">
          <div class="vctrl"><input id="delayTime" type="range" min="0" max="33" step="1" value="5"></div>
          <div class="fxLab">Time</div>
          <span id="delayTimeVal" class="fxVal">1/8</span>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="delayFb" type="range" min="0" max="0.95" step="0.01" value="0.24"></div>
          <div class="fxLab">Feedback</div>
          <span id="delayFbVal" class="fxVal">24%</span>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="delayTone" type="range" min="400" max="12000" value="2800"></div>
          <div class="fxLab">Tone</div>
          <span class="fxVal">&nbsp;</span>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="fxReact" type="range" min="0" max="2" step="0.01" value="1.2"></div>
          <div class="fxLab">React</div>
          <span class="fxVal">&nbsp;</span>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="delayWarble" type="range" min="0" max="1" step="0.01" value="0"></div>
          <div class="fxLab">Warble</div>
          <span class="fxVal">&nbsp;</span>
        </div>
      </div>
    </div>

    <!-- Reverse Ghost -->
    <div class="fxModule" aria-label="Reverse Ghost" data-effect="ghost">
      <div class="fxTitle" draggable="true" style="cursor: grab;">Reverse Ghost</div>
      <div class="fxFaders">
        <div class="vfader"><div class="vctrl"><input id="ghostLen" type="range" min="0.005" max="2.0" step="0.005" value="0.8"></div>
          <div class="fxLab">Length</div></div>
        <div class="vfader"><div class="vctrl"><input id="ghostPitch" type="range" min="-24" max="24" step="1" value="0"></div>
          <div class="fxLab">Pitch</div></div>
        <div class="vfader"><div class="vctrl"><input id="ghostBoost" type="range" min="0" max="2" step="0.01" value="0.2"></div>
          <div class="fxLab">Mix</div></div>
        <div class="vfader"><div class="vctrl"><input id="ghostDensity" type="range" min="0" max="1" step="0.01" value="0.5"></div>
          <div class="fxLab">Density</div></div>
        <div class="vfader"><div class="vctrl"><input id="ghostReverse" type="range" min="0" max="1" step="0.01" value="0.6"></div>
          <div class="fxLab">Reverse</div></div>
        <div class="vfader"><div class="vctrl"><input id="ghostOblique" type="range" min="0" max="1" step="0.01" value="0"></div>
          <div class="fxLab">Oblique</div></div>
        <div class="vfader"><div class="vctrl"><input id="ghostRev" type="range" min="0" max="1" step="0.01" value="0.8"></div>
          <div class="fxLab">Reverb</div></div>
      </div>
      <div class="fxFooter" id="ghostClockFooter">
        <span class="small">Clock</span>
        <select id="ghostClock">
          <option value="1">Whole</option>
          <option value="2">Half</option>
          <option value="4" selected>Quarter</option>
          <option value="8">Eighth</option>
          <option value="16">16th</option>
        </select>
      </div>
    </div>

    <!-- Hum -->
    <div class="fxModule" aria-label="Hum" data-effect="hum">
      <div class="fxTitle" draggable="true" style="cursor: grab;">Hum</div>
      <div class="fxFaders">
        <div class="vfader"><div class="vctrl"><input id="humBase" type="range" min="60" max="800" step="1" value="220"></div>
          <div class="fxLab">Root</div></div>
        <div class="vfader"><div class="vctrl"><input id="humColor" type="range" min="-1" max="1" step="0.01" value="0"></div>
          <div class="fxLab">Bloom</div></div>
        <div class="vfader"><div class="vctrl"><input id="humTail" type="range" min="0.5" max="24.0" step="0.1" value="12.0"></div>
          <div class="fxLab">Tail</div></div>
        <div class="vfader"><div class="vctrl"><input id="humWet" type="range" min="0" max="1" step="0.01" value="1"></div>
          <div class="fxLab">Wet</div></div>
      </div>
      <!-- H05: Removed Follow checkbox - unnecessary with per-track sends -->
    </div>

    <!-- Harmonic Gate -->
    <div class="fxModule" aria-label="Harmonic Gate" data-effect="hg">
      <div class="fxTitle" draggable="true" style="cursor: grab;">Harmonic Gate</div>
      <div class="fxFaders">
        <div class="vfader">
          <div class="vctrl"><input id="hgMix" type="range" min="0" max="1" step="0.01" value="0"></div>
          <div class="fxLab">Mix</div>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="hgQ" type="range" min="5" max="200" step="1" value="20"></div>
          <div class="fxLab">Q</div>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="hgResonance" type="range" min="0" max="1" step="0.01" value="0.3"></div>
          <div class="fxLab">Resonance</div>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="hgGain" type="range" min="1" max="10" step="0.1" value="3"></div>
          <div class="fxLab">Gain</div>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="hgThreshold" type="range" min="0" max="1" step="0.01" value="0"></div>
          <div class="fxLab">Threshold</div>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="hgAttack" type="range" min="1" max="100" step="1" value="5"></div>
          <div class="fxLab">Attack</div>
        </div>
        <div class="vfader">
          <div class="vctrl"><input id="hgRelease" type="range" min="1" max="200" step="1" value="50"></div>
          <div class="fxLab">Release</div>
        </div>
      </div>
    </div>

  </div>

  </div><!-- End .stickyHeader -->


  <div class="grid" id="grid"></div>

<script>

/* ===== Constants ===== */
const SOUND_NAMES = ["Kik","Dusk","Open","Base","Bloom","Ritual","Poli","Prog","Silencer","Phrases"];

// Per-track recording cap in seconds (uniform for this version)
const TRACK_CAP_SEC = new Array(SOUND_NAMES.length).fill(60);

const ROW_TINTS = [
  'rgba(110,231,183,0.18)','rgba(251,191,36,0.18)','rgba(147,197,253,0.18)','rgba(244,114,182,0.18)',
  'rgba(129,140,248,0.18)','rgba(248,113,113,0.18)','rgba(94,234,212,0.18)','rgba(165,180,252,0.18)',
  'rgba(156,163,175,0.18)', // Silencer (gray)
  'rgba(236,72,153,0.18)'   // A01: Phrases (pink)
];
const NUM_SOUNDS = SOUND_NAMES.length;
const N_STEPS = 16;        // Steps per page (UI constant)
const MAX_STEPS = 64;      // Total steps across all pages (data storage)


// CR-024: smoothed density for Reverse Ghost to avoid CPU spikes on rapid UI changes
let ghostDensitySmooth = 0.5;

/* ===== Audio Graph ===== */
const AudioContextClass = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContextClass();

const dryGain = audioCtx.createGain();  dryGain.gain.value = 0.75;
const busSum  = audioCtx.createGain();
busSum.gain.value = 1.0;  // H01: Removed stray audioCtx.createGain()
const comp    = audioCtx.createDynamicsCompressor();

/* ===== Effect Routing Splits (declared early, before effects use them) ===== */
const majaRouteSplit = audioCtx.createGain(); majaRouteSplit.gain.value = 1.0;
const dubRouteSplit = audioCtx.createGain(); dubRouteSplit.gain.value = 1.0;
const ghostRouteSplit = audioCtx.createGain(); ghostRouteSplit.gain.value = 1.0;
const humRouteSplit = audioCtx.createGain(); humRouteSplit.gain.value = 1.0;
const hgRouteSplit = audioCtx.createGain(); hgRouteSplit.gain.value = 1.0;
comp.threshold.value = -12; comp.knee.value = 12; comp.ratio.value = 3;
comp.attack.value = 0.005; comp.release.value = 0.15;
const postLimiter = audioCtx.createGain(); postLimiter.gain.value = 0.80;
const outGain = audioCtx.createGain(); outGain.gain.value = 0.86;

/* Dub bus (per-track sends) */
const delayIn = audioCtx.createGain();
/* Dub React detector: only reacts to signals actually sent to Dub */
const dubReactTap = audioCtx.createGain();
const dubReactAnalyser = audioCtx.createAnalyser();
dubReactAnalyser.fftSize = 256;
dubReactAnalyser.smoothingTimeConstant = 0.65;
delayIn.connect(dubReactTap).connect(dubReactAnalyser);
let __dubReactEnv = 0.0;
(function dubReactMeter(){
  try{
    const buf = new Uint8Array(dubReactAnalyser.fftSize);
    dubReactAnalyser.getByteTimeDomainData(buf);
    // Compute RMS in 0..1
    let sum=0; for(let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; sum+=v*v; }
    const rms = Math.sqrt(sum/buf.length);
    // Smooth envelope
    const target = Math.min(1, rms*2.5);
    __dubReactEnv = __dubReactEnv*0.85 + target*0.15;
  }catch(_){}
  requestAnimationFrame(dubReactMeter);
})();
const delayNode = audioCtx.createDelay(4.0);
const delayFb = audioCtx.createGain(); delayFb.gain.value = 0.24; // G01: Reduced default feedback
const delayTone = audioCtx.createBiquadFilter(); delayTone.type='lowpass'; delayTone.frequency.value = 2800;
const delaySat = audioCtx.createWaveShaper(); delaySat.curve = makeTanhCurve(0.35);
const delayWet = audioCtx.createGain(); delayWet.gain.value = 0.55;
const delayHP = audioCtx.createBiquadFilter(); delayHP.type='highpass'; delayHP.frequency.value = 120;
const delayComp = audioCtx.createDynamicsCompressor();
delayComp.threshold.value = -18; delayComp.knee.value = 12; delayComp.ratio.value = 3;
delayComp.attack.value = 0.003; delayComp.release.value = 0.08;
try{ delaySat.oversample = '4x'; }catch(_){ }
/* Soft ceiling on wet only */
const delayWetCeil = audioCtx.createWaveShaper(); delayWetCeil.curve = makeTanhCurve(0.9);

delayIn.connect(delayNode);
// insert saturator inside feedback loop
delayNode.connect(delayHP).connect(delayTone).connect(delaySat).connect(delayComp).connect(delayFb).connect(delayNode);
delayNode.connect(delayWet)
// === Dub Warble (wow + flutter + drift) — more extreme at max ===
let __dubWarbleAmt = 0.0;

// LFOs (slowed down for more musical modulation)
const dubWowLFO = audioCtx.createOscillator(); dubWowLFO.type = 'sine'; dubWowLFO.frequency.value = 0.25;  // slower wow
const dubFlutLFO = audioCtx.createOscillator(); dubFlutLFO.type = 'sine'; dubFlutLFO.frequency.value = 3.5;  // slower flutter

// Depth controls (seconds)
const dubWowDepth = audioCtx.createGain();   dubWowDepth.gain.value = 0.0;
const dubFlutDepth = audioCtx.createGain();  dubFlutDepth.gain.value = 0.0;

// Connect LFOs to delay time
try { dubWowLFO.connect(dubWowDepth).connect(delayNode.delayTime); dubFlutLFO.connect(dubFlutDepth).connect(delayNode.delayTime); dubWowLFO.start(); dubFlutLFO.start(); } catch(_){}

// Drift via ConstantSource (gentle)
const dubDrift = audioCtx.createConstantSource ? audioCtx.createConstantSource() : null;
if (dubDrift) { dubDrift.offset.value = 0.0; try { dubDrift.connect(delayNode.delayTime); dubDrift.start(); } catch(_) {} }

function __dubGetDelaySeconds(){ try { return Math.max(0.002, Math.min(3.8, delayNode.delayTime.value)); } catch(_){ return 0.25; } }

function applyDubWarble(amount){
  __dubWarbleAmt = Math.max(0, Math.min(1, amount||0));
  const depth = Math.pow(__dubWarbleAmt, 0.7);
  const delaySec = __dubGetDelaySeconds();
  const autoScale = Math.max(0.15, Math.min(1, delaySec / 0.12));

  // Max depths at Warble=1 before autoScale (more extreme)
  const maxWow = 0.006;    // 6.0 ms (up from 3.5ms)
  const maxFlut = 0.0012;  // 1.2 ms (up from 0.6ms)
  const maxDrift = 0.0025; // ±2.5 ms (up from ±1.2ms)

  const wow = depth * autoScale * maxWow;
  const flt = depth * autoScale * maxFlut;
  const driftMax = depth * autoScale * maxDrift;

  const now = audioCtx.currentTime;
  try { dubWowDepth.gain.setTargetAtTime(wow, now, 0.12); } catch(_) { dubWowDepth.gain.value = wow; }
  try { dubFlutDepth.gain.setTargetAtTime(flt, now, 0.12); } catch(_) { dubFlutDepth.gain.value = flt; }

  // Drift random walk
  if (dubDrift){
    if (typeof window.__dubDriftTimer !== 'number'){
      window.__dubDriftTarget = 0.0;
      window.__dubDriftTimer = setInterval(()=>{
        const step = (Math.random()*2 - 1) * (driftMax * 0.25);
        window.__dubDriftTarget = Math.max(-driftMax, Math.min(driftMax, window.__dubDriftTarget + step));
        const tNow = audioCtx.currentTime;
        try { dubDrift.offset.setTargetAtTime(window.__dubDriftTarget, tNow, 0.12); } catch(_) { dubDrift.offset.value = window.__dubDriftTarget; }
      }, 80);
    }
  }

  // Subtle stereo expansion at extreme Warble (no center shift)
  try {
    const stereo = Math.max(0, Math.min(1, (__dubWarbleAmt - 0.8) / 0.2)); // only above ~0.8
    if (stereo > 0 && typeof dubSideGainA !== 'undefined' && typeof dubSideGainB !== 'undefined'){
      const now2 = audioCtx.currentTime;
      const curA = dubSideGainA.gain.value || 1.0;
      const curB = dubSideGainB.gain.value || 1.0;
      const factor = 1 + 0.04 * stereo; // up to +4% width boost
      dubSideGainA.gain.setTargetAtTime(curA * factor, now2, 0.15);
      dubSideGainB.gain.setTargetAtTime(curB * factor, now2, 0.15);
    }
  } catch(_){}
}
;
// Dub widener (simple Haas-effect stereo widener)
const dubSplit = audioCtx.createChannelSplitter(2);
const dubMerger = audioCtx.createChannelMerger(2);

// Direct paths (dry L/R)
const dubDryL = audioCtx.createGain(); dubDryL.gain.value = 1.0;
const dubDryR = audioCtx.createGain(); dubDryR.gain.value = 1.0;

// Cross paths with allpass decorrelation (creates width)
const dubCrossL = audioCtx.createGain(); dubCrossL.gain.value = 0.0;  // controlled by React
const dubCrossR = audioCtx.createGain(); dubCrossR.gain.value = 0.0;  // controlled by React

// Allpass filters for decorrelation (different for each channel)
const dubAP_L = audioCtx.createBiquadFilter(); dubAP_L.type = 'allpass'; dubAP_L.frequency.value = 2200; dubAP_L.Q.value = 0.7;
const dubAP_R = audioCtx.createBiquadFilter(); dubAP_R.type = 'allpass'; dubAP_R.frequency.value = 1600; dubAP_R.Q.value = 0.7;

// Split wet signal
delayWet.connect(dubSplit);

// Left channel: dry L + decorrelated R
dubSplit.connect(dubDryL, 0);           // L → left output
dubSplit.connect(dubAP_R, 1);           // R → allpass
dubAP_R.connect(dubCrossL);             // decorrelated R → left (for width)
dubDryL.connect(dubMerger, 0, 0);
dubCrossL.connect(dubMerger, 0, 0);

// Right channel: dry R + decorrelated L
dubSplit.connect(dubDryR, 1);           // R → right output
dubSplit.connect(dubAP_L, 0);           // L → allpass
dubAP_L.connect(dubCrossR);             // decorrelated L → right (for width)
dubDryR.connect(dubMerger, 0, 1);
dubCrossR.connect(dubMerger, 0, 1);

// To ceiling and bus
dubMerger.connect(delayWetCeil).connect(dubRouteSplit);
dubRouteSplit.connect(busSum); // Default: always send to master





/* Analog Maja Bus */
const majaIn  = audioCtx.createGain();
const majaLP  = audioCtx.createBiquadFilter(); majaLP.type='lowpass';
const majaHP  = audioCtx.createBiquadFilter(); majaHP.type='highpass';
const majaMixLP = audioCtx.createGain(); majaMixLP.gain.value = 0.5;
const majaMixHP = audioCtx.createGain(); majaMixHP.gain.value = 0.5;
const majaDrive = audioCtx.createWaveShaper();
const majaAir = audioCtx.createBiquadFilter(); majaAir.type='highshelf'; majaAir.frequency.value = 8000;

// Maja wet gain and stereo panner (for Spread control)
const majaWet = audioCtx.createGain(); 
majaWet.gain.value = 1.0;

const majaPan = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null;

// Pan LFO used by the Spread slider; starts at silent depth
const majaPanLFO = audioCtx.createOscillator();
majaPanLFO.type = 'sine';

const majaPanAmt = audioCtx.createGain();
majaPanAmt.gain.value = 0.0; // depth is 0 until the slider says otherwise

try {
  if (majaPan) {
    majaPanLFO.connect(majaPanAmt).connect(majaPan.pan);
    majaPanLFO.start();
  }
} catch(_) {}


const airVerb = audioCtx.createConvolver(); airVerb.normalize = false;
function makeAirIR(ctx, lenSec=0.09, decay=14){
  const sr = ctx.sampleRate; const n = Math.max(1, Math.floor(lenSec*sr));
  const buf = ctx.createBuffer(2, n, sr);
  for (let ch=0; ch<2; ch++){
    const d = buf.getChannelData(ch);
    let prev = 0;
    for (let i=0;i<n;i++){
      const t = i/n; const env = Math.exp(-decay*t);
      const rnd = Math.random()*2-1;
      const hf = rnd - prev*0.85; prev = rnd;
      d[i] = hf * env * 0.5;
    }
  }
  return buf;
}
airVerb.buffer = makeAirIR(audioCtx);
const airVerbWet = audioCtx.createGain(); 
airVerbWet.gain.value = 0.0;

majaIn.connect(majaLP).connect(majaMixLP);
majaIn.connect(majaHP).connect(majaMixHP);

const majaSum = audioCtx.createGain(); 
majaSum.gain.value = 1;

majaMixLP.connect(majaSum);
majaMixHP.connect(majaSum);

// Drive + Air EQ, then into wet gain and optional pan before hitting the main bus
majaSum.connect(majaDrive).connect(majaAir).connect(majaWet);

if (majaPan) {
  majaWet.connect(majaPan).connect(majaRouteSplit);
} else {
  majaWet.connect(majaRouteSplit);
}
majaRouteSplit.connect(busSum); // Default: always send to master

// Legacy Air verb stays wired but is no longer controlled by the slider
majaAir.connect(airVerb);
airVerb.connect(airVerbWet);
airVerbWet.connect(busSum); // Air verb stays direct to busSum




/* ===== HUM FX BUS - ALGORITHMIC "CELLO IN CATHEDRAL" REVERB =====
   Architecture: stable modal Body -> FDN diffusion tail
   - No convolvers, no IR rebuilds, no buffer swaps
   - Tail length via smoothed feedback coefficient
   - Auto HF damping increases with tail
   - Subtle "breath" motion via spectral balance drift */

const humIn = audioCtx.createGain();

// Pre-emphasis: gentle low-mid boost for "bloom"
const humPreTilt = audioCtx.createBiquadFilter();
humPreTilt.type = 'peaking';
humPreTilt.frequency.value = 300;
humPreTilt.Q.value = 0.7;
humPreTilt.gain.value = 3; // subtle bloom

// BODY: 5 stable modal peaks with self-normalization
const humFilters = [];
const humRatios = [1.00, 2.02, 2.99, 3.98, 5.03];
const humBodySum = audioCtx.createGain(); // modal body output
// D04 FIX: this bus was overly attenuated (could make HUM effectively inaudible even with Send/Wet/Tail at max)
// Keep it conservative but clearly audible.
humBodySum.gain.value = 0.55;

for (let k=0; k<5; k++){
  const f = audioCtx.createBiquadFilter();
  f.type = 'peaking';
  f.Q.value = 4.5 + k*0.35; // slightly broader, less ringy
  f.gain.value = 2.5; // gentler modal strength (avoids fuzz in long tails) // consistent modal strength
  humFilters.push(f);
}

// TAIL: FDN-style algorithmic reverb (4 delay lines + feedback matrix)
// Prime-ish delay times for dense diffusion
const humDelayTimes = [0.0413, 0.0531, 0.0677, 0.0799]; // 41–80ms: smoother build + less metallic flutter // ~37-61ms, coprime-ish
const humDelays = humDelayTimes.map(t => {
  const d = audioCtx.createDelay(1.0);
  d.delayTime.value = t;
  return d;
});

// One-pole lowpass damping in each delay line
const humDampFilters = [];
for (let i=0; i<4; i++){
  const lp = audioCtx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.value = 4000; // will be modulated by Tail param
  lp.Q.value = 0.707;
  humDampFilters.push(lp);
}

// Feedback gains (will be modulated by Tail param)
const humFeedbackGains = [];
for (let i=0; i<4; i++){
  const g = audioCtx.createGain();
  g.gain.value = 0.55; // balanced for audibility + stability
  humFeedbackGains.push(g);
}

// Simplified Hadamard-ish feedback matrix (2x2 Householder applied twice)
// [a, b, c, d] -> [a+b+c+d, a-b+c-d, a+b-c-d, a-b-c+d] / 4 (normalized)
const humMatrixInputs = []; // collect delay outputs
const humMatrixOutputs = []; // distribute back to delay inputs
for (let i=0; i<4; i++){
  humMatrixInputs[i] = audioCtx.createGain();
    humMatrixInputs[i].gain.value = 0.5; // Hadamard normalization (1/sqrt(4))
  humMatrixOutputs[i] = audioCtx.createGain();
  humMatrixOutputs[i].gain.value = 1.0;
}

// Wire the feedback matrix: output -> damp -> feedback gain -> matrix input
for (let i=0; i<4; i++){
  humDelays[i].connect(humDampFilters[i]);

  // Extra diffusion inside the loop (allpass) to reduce metallic ringing at long tails
  // Allpass is stable and fixed; it increases echo density without gain.
  const ap = audioCtx.createBiquadFilter();
  ap.type = 'allpass';
  ap.frequency.value = 900 + i*500;
  ap.Q.value = 0.7;
  humDampFilters[i].connect(ap);

  ap.connect(humFeedbackGains[i]);
  humFeedbackGains[i].connect(humMatrixInputs[i]);

}

// Matrix multiplication (Hadamard-ish):
// Implemented via separate gain nodes for positive/negative paths
// out[0] = in[0] + in[1] + in[2] + in[3]
// out[1] = in[0] - in[1] + in[2] - in[3]
// out[2] = in[0] + in[1] - in[2] - in[3]
// out[3] = in[0] - in[1] - in[2] + in[3]

const humMatrixNegs = []; // inverted gain nodes for negative coefficients
for (let i=0; i<12; i++){ // need several inverters
  const neg = audioCtx.createGain();
  neg.gain.value = -1.0; // just invert (scaling already done by humMatrixInputs)
  humMatrixNegs.push(neg);
}

// Row 0: all positive
humMatrixInputs[0].connect(humMatrixOutputs[0]);
humMatrixInputs[1].connect(humMatrixOutputs[0]);
humMatrixInputs[2].connect(humMatrixOutputs[0]);
humMatrixInputs[3].connect(humMatrixOutputs[0]);

// Row 1: + - + -
humMatrixInputs[0].connect(humMatrixOutputs[1]);
humMatrixInputs[1].connect(humMatrixNegs[0]); humMatrixNegs[0].connect(humMatrixOutputs[1]);
humMatrixInputs[2].connect(humMatrixOutputs[1]);
humMatrixInputs[3].connect(humMatrixNegs[1]); humMatrixNegs[1].connect(humMatrixOutputs[1]);

// Row 2: + + - -
humMatrixInputs[0].connect(humMatrixOutputs[2]);
humMatrixInputs[1].connect(humMatrixOutputs[2]);
humMatrixInputs[2].connect(humMatrixNegs[2]); humMatrixNegs[2].connect(humMatrixOutputs[2]);
humMatrixInputs[3].connect(humMatrixNegs[3]); humMatrixNegs[3].connect(humMatrixOutputs[2]);

// Row 3: + - - +
humMatrixInputs[0].connect(humMatrixOutputs[3]);
humMatrixInputs[1].connect(humMatrixNegs[4]); humMatrixNegs[4].connect(humMatrixOutputs[3]);
humMatrixInputs[2].connect(humMatrixNegs[5]); humMatrixNegs[5].connect(humMatrixOutputs[3]);
humMatrixInputs[3].connect(humMatrixOutputs[3]);

// Close feedback loops: matrix outputs -> delay inputs
for (let i=0; i<4; i++){
  humMatrixOutputs[i].connect(humDelays[i]);
}

// Tap point: mix body output into delays (CRITICAL: inject body into FDN)
const humBodyToTail = audioCtx.createGain();
// D04 FIX: restore healthy injection level into the FDN
humBodyToTail.gain.value = 1.0;
// Connect body output to tail input (must happen here, after both nodes exist)
// Diffusion before the tail: a short allpass chain to increase density without increasing gain
const humInDiffusers = [];
const humInDiffuserFreqs = [700, 1100, 1700, 2600];
for (let i=0; i<4; i++){
  const ap = audioCtx.createBiquadFilter();
  ap.type = 'allpass';
  ap.frequency.value = humInDiffuserFreqs[i];
  ap.Q.value = 0.7;
  humInDiffusers.push(ap);
}

// Connect body output to tail input via diffusers (must happen here, after nodes exist)
let __humDiffChain = humBodySum;
humInDiffusers.forEach(ap => { __humDiffChain.connect(ap); __humDiffChain = ap; });
__humDiffChain.connect(humBodyToTail);

// Distribute to all 4 delay lines

for (let i=0; i<4; i++){
  humBodyToTail.connect(humDelays[i]);
}

// Output: sum all delay taps
const humTailSum = audioCtx.createGain();
// D04 FIX: tail return was too quiet; raise for audible wet.
humTailSum.gain.value = 1.15;
for (let i=0; i<4; i++){
  humDelays[i].connect(humTailSum);
}

// BREATH: subtle spectral balance drift (3 bands)
// Ultra-slow random walk (breath cycle ~10-30s)
const humBreathBands = [];
const humBreathFreqs = [200, 800, 3200];
for (let i=0; i<3; i++){
  const bp = audioCtx.createBiquadFilter();
  bp.type = 'peaking';
  bp.frequency.value = humBreathFreqs[i];
  bp.Q.value = 1.5;
  bp.gain.value = 0.0; // will drift ±1dB
  humBreathBands.push(bp);
}

// Breath animation loop
let humBreathTargets = [0, 0, 0]; // target gains for each band
let humBreathCurrent = [0, 0, 0]; // current interpolated values
function humBreathTick(){
  try{
    const now = audioCtx.currentTime;
    for (let i=0; i<3; i++){
      // Slowly drift towards target
      humBreathCurrent[i] += (humBreathTargets[i] - humBreathCurrent[i]) * 0.005;
      // Occasionally pick new target (1% chance per tick = ~every 3-5s at 30fps)
      if (Math.random() < 0.01){
        humBreathTargets[i] = (Math.random()*2 - 1) * 1.0; // ±1dB
      }
      humBreathBands[i].gain.setTargetAtTime(humBreathCurrent[i], now, 0.3);
    }
    requestAnimationFrame(humBreathTick);
  }catch(_){}
}
requestAnimationFrame(humBreathTick);

// Final wet mix
const humWet = audioCtx.createGain();
humWet.gain.value = 1.0; // return level (safe: sends default to 0)

function setHumWet(val){
  try{
    const now = audioCtx.currentTime;
    try { humWet.gain.cancelAndHoldAtTime(now); } catch(_){
      try{ humWet.gain.cancelScheduledValues(now); } catch(__){}
    }
    const v = (+val||0) * 1.6; // perceptual lift without constant clipping
    humWet.gain.setTargetAtTime(v, now, 0.06); // 60ms smooth // 30ms smooth
    if (typeof hum!=='undefined') hum.wet = +val||0;
  }catch(_){}
}


// Gentle safety compressor on HUM return (keeps it lush; avoids fuzz)
const humPostComp = audioCtx.createDynamicsCompressor();
humPostComp.threshold.value = -16;
humPostComp.knee.value = 18;
humPostComp.ratio.value = 2.0;
humPostComp.attack.value = 0.010;
humPostComp.release.value = 0.120;


// SIGNAL FLOW: Wire input and output chains
// humIn -> preTilt -> [5 modal filters in series] -> bodySum (then → bodyToTail, wired above)
humIn.connect(humPreTilt);
let hChain = humPreTilt;
humFilters.forEach(f => { hChain.connect(f); hChain = f; });
hChain.connect(humBodySum);
// (bodySum → bodyToTail connection is in FDN section above)

// Wire tail output: tailSum -> [3 breath bands in series] -> humWet -> output
let bChain = humTailSum;
humBreathBands.forEach(b => { bChain.connect(b); bChain = b; });
bChain.connect(humWet);
humWet.connect(humPostComp).connect(humRouteSplit);
humRouteSplit.connect(busSum);

/* ===== F17: Harmonic Framework (moved here to fix initialization order) ===== */
// Global root note (0=C, 1=C#, 2=D, 3=D#, 4=E, 5=F, 6=F#, 7=G, 8=G#, 9=A, 10=A#, 11=B)
let globalRoot = 0;
// Global scale selection
let globalScale = 'chromatic';
// Scale definitions: semitone intervals from root
const scaleDefinitions = {
  chromatic: [0,1,2,3,4,5,6,7,8,9,10,11],
  major: [0,2,4,5,7,9,11],
  minor: [0,2,3,5,7,8,10],
  pentatonicMajor: [0,2,4,7,9],
  pentatonicMinor: [0,3,5,7,10]
};

/* ===== Harmonic Gate (Spectral Resonator Bank) ===== */
const hgIn = audioCtx.createGain();
const hgAnalyser = audioCtx.createAnalyser();
hgAnalyser.fftSize = 256;
hgAnalyser.smoothingTimeConstant = 0.3;
const hgGateEnv = audioCtx.createGain(); hgGateEnv.gain.value = 1.0; // Envelope-controlled gate
const hgDry = audioCtx.createGain(); hgDry.gain.value = 1.0;
const hgWet = audioCtx.createGain(); hgWet.gain.value = 0.0;
const hgOut = audioCtx.createGain(); hgOut.gain.value = 1.0;

// Resonator bank: array of bandpass filters tuned to scale frequencies
let hgResonators = [];
let hgResonatorSum = null;

// Envelope follower state
let hgEnvelope = 0.0; // Current envelope value (0-1)
let hgEnvelopeActive = false; // Is envelope follower running?

// Harmonic Gate parameters
let hgMix = 0.0;        // dry/wet mix (0-1)
let hgQ = 20;           // filter Q factor (5-200)
let hgResonance = 0.3;  // filter gain/resonance (0-1)
let hgGain = 3.0;       // output gain (1-20x)
let hgThreshold = 0.0;  // gate threshold (0-1)
let hgAttack = 5;       // gate attack in ms
let hgRelease = 50;     // gate release in ms

// Generate scale frequencies from base frequency across multiple octaves
function getScaleFrequencies(rootNote, scaleName, minHz = 30, maxHz = 8000) {
  const scale = scaleDefinitions[scaleName] || scaleDefinitions.chromatic;
  const frequencies = [];

  // C0 is at 16.35 Hz, we want to start from minHz
  const baseC = 16.35; // C0
  let octave = 0;

  while (true) {
    let addedAny = false;
    for (let i = 0; i < scale.length; i++) {
      const semitones = octave * 12 + rootNote + scale[i];
      const freq = baseC * Math.pow(2, semitones / 12);

      if (freq >= minHz && freq <= maxHz) {
        frequencies.push(freq);
        addedAny = true;
      }
    }

    if (!addedAny && octave > 0) break; // No frequencies in range in this octave
    octave++;
    if (octave > 10) break; // Safety limit
  }

  return frequencies.sort((a, b) => a - b);
}

// Build resonator bank based on current global key/scale
function rebuildHarmonicGate() {
  try {
    // Disconnect old resonators
    if (hgResonatorSum) {
      try { hgResonatorSum.disconnect(); } catch(_) {}
    }
    hgResonators.forEach(r => {
      try { r.disconnect(); } catch(_) {}
    });
    hgResonators = [];

    // Create new resonator sum node
    hgResonatorSum = audioCtx.createGain();
    hgResonatorSum.gain.value = 1.0;

    // C17: Generate only root note frequencies across octaves (destructive pitch quantizer)
    // Override scale to use only [0] (root) instead of full scale
    const rootOnlyScale = [0];
    const frequencies = [];
    const baseC = 16.35; // C0
    let octave = 0;

    while (true) {
      let addedAny = false;
      for (let i = 0; i < rootOnlyScale.length; i++) {
        const semitones = octave * 12 + globalRoot + rootOnlyScale[i];
        const freq = baseC * Math.pow(2, semitones / 12);

        if (freq >= 30 && freq <= 8000) {
          frequencies.push(freq);
          addedAny = true;
        }
      }

      if (!addedAny && octave > 0) break;
      octave++;
      if (octave > 10) break;
    }

    const freqs = frequencies.sort((a, b) => a - b);

    // Create bandpass filter for each frequency
    freqs.forEach(freq => {
      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = freq;
      bp.Q.value = hgQ;
      bp.gain.value = 0; // Bandpass doesn't use gain, but set for consistency

      // Connect: hgGateEnv -> bandpass -> resonatorSum
      hgGateEnv.connect(bp);
      bp.connect(hgResonatorSum);

      hgResonators.push(bp);
    });

    // Normalize output based on number of resonators, then apply Resonance (1x to 10x)
    const normGain = Math.max(0.1, Math.min(1.0, 1.0 / Math.sqrt(hgResonators.length / 10)));
    const resGain = normGain * (1.0 + hgResonance * 9.0);  // More extreme: 1x to 10x
    hgResonatorSum.gain.value = resGain;

    // Connect resonator sum to wet
    hgResonatorSum.connect(hgWet);

  } catch(e) {
    console.error('[Harmonic Gate] Error rebuilding:', e);
  }
}

// Envelope follower for dynamic gating
function updateHarmonicGateEnvelope() {
  if (!hgEnvelopeActive) return;

  try {
    // Get current input level from analyser
    const bufferLength = hgAnalyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    hgAnalyser.getByteTimeDomainData(dataArray);

    // Calculate RMS level (0-1 range)
    let sum = 0;
    for (let i = 0; i < bufferLength; i++) {
      const normalized = (dataArray[i] - 128) / 128; // Convert to -1 to +1
      sum += normalized * normalized;
    }
    const rms = Math.sqrt(sum / bufferLength);

    // Target gate value: 1.0 if above threshold, 0.0 if below
    const targetGate = rms > hgThreshold ? 1.0 : 0.0;

    // Apply attack/release smoothing with tiny envelope to avoid pops
    const attackTime = Math.max(5, hgAttack) / 1000; // Convert ms to seconds, min 5ms
    const releaseTime = Math.max(5, hgRelease) / 1000; // Convert ms to seconds, min 5ms

    if (targetGate > hgEnvelope) {
      // Attack: gate opening
      const attackRate = 1.0 / (attackTime * 60); // Rate per frame at ~60fps
      hgEnvelope = Math.min(1.0, hgEnvelope + attackRate / 60);
    } else {
      // Release: gate closing
      const releaseRate = 1.0 / (releaseTime * 60); // Rate per frame at ~60fps
      hgEnvelope = Math.max(0.0, hgEnvelope - releaseRate / 60);
    }

    // Update gate gain with tiny smoothing to avoid clicks
    const now = audioCtx.currentTime;
    hgGateEnv.gain.setTargetAtTime(hgEnvelope, now, 0.005); // 5ms smoothing

  } catch(e) {
    console.error('[Harmonic Gate] Envelope error:', e);
  }

  // Continue loop
  requestAnimationFrame(updateHarmonicGateEnvelope);
}

// Start envelope follower
hgEnvelopeActive = true;
updateHarmonicGateEnvelope();

// Routing: hgIn -> analyser -> gateEnv -> [dry + wet] -> out -> split -> busSum
hgIn.connect(hgAnalyser);
hgAnalyser.connect(hgGateEnv);
hgGateEnv.connect(hgDry);
hgDry.connect(hgOut);
hgWet.connect(hgOut);
hgOut.connect(hgRouteSplit);
hgRouteSplit.connect(busSum); // Default: always send to master

// Initialize resonator bank
rebuildHarmonicGate();

/* Helpers to apply UI params (safe even if silent) */
// ===== E02: Harmonic Bias (phrase-scale drift) globals (declared early to avoid TDZ) =====
let harmonicBias = 0.0;
let harmonicBiasDepth = 0.05;   // maps to ±5% on Hum base (safe, non-"tuning")
let harmonicBiasBars  = 32;     // cycle length in bars

function applyHumParams(){
  try{
    const root = (typeof hum!=='undefined' ? hum.baseHz : 220); // renamed: fundamental → root
    const bloom = (typeof hum!=='undefined' ? hum.color : 0); // -1 to +1
    const tail = (typeof hum!=='undefined' ? hum.tailSec : 3.0); // 0.5 to 24.0
    const now = audioCtx.currentTime;

    // ROOT: Update modal filter frequencies + character
    // Low root = tighter resonances (higher Q), high = broader/airier (lower Q)
    const rootNorm = (root - 60) / (800 - 60); // 0..1

    // D09/I01: Make Root more audible by also affecting modal body level
    // Low root = more body resonance, high root = cleaner/airier
    // I01: Increased ~2.5% (0.55-0.8 → 0.56-0.82) for subtly more audible resonance
    const bodyLevelAdjust = 0.56 + 0.26 * (1 - rootNorm); // 0.56 at high, 0.82 at low
    humBodySum.gain.setTargetAtTime(bodyLevelAdjust, now, 0.08);

    for (let k=0; k<humFilters.length; k++){
      const targetHz = Math.max(60, Math.min(16000, root * humRatios[k]));
      humFilters[k].frequency.setTargetAtTime(targetHz, now, 0.05);

      // Adjust Q: low root = tight/focused (Q↑), high = open/airy (Q↓)
      const qBase = 4.5 + k*0.35;
      const qAdjust = 2.5 * (1 - rootNorm); // +2.5 at low end, 0 at high end (increased from 1.8)
      humFilters[k].Q.setTargetAtTime(qBase + qAdjust, now, 0.05);
    }

    // Also adjust bloom center frequency based on root
    // Low root = bloom centers lower, high = bloom centers higher
    const bloomCenter = 180 + rootNorm * 280; // 180Hz -> 460Hz (wider range)
    humPreTilt.frequency.setTargetAtTime(bloomCenter, now, 0.05);

    // BLOOM: controls pre-tilt gain + tail character
    // Increased range: -1 = very dark/dry, 0 = neutral, +1 = lush/bloomy
    const bloomCurve = Math.sign(bloom) * Math.pow(Math.abs(bloom), 0.8); // stronger at extremes
    const tiltGain = bloomCurve * 7; // ±7dB range
    humPreTilt.gain.setTargetAtTime(tiltGain, now, 0.05);

    // Bloom also affects how much signal feeds the tail
    // Positive bloom = more tail feed (lush), negative = less (dry/intimate)
    const tailFeedAdjust = 0.7 + bloom * 0.25; // 0.45 to 0.95
    humBodyToTail.gain.setTargetAtTime(tailFeedAdjust, now, 0.08);

    // TAIL: controls feedback gain AND damping
    // Longer tail = higher feedback, darker damping, reduced modal ring
    const fbNorm = Math.max(0, Math.min(1, (tail - 0.5) / 23.5)); // 0..1

    // D08: Reduced max feedback from ~0.98 to ~0.90 for stability
    const feedbackAmount = 0.58 + 0.32 * Math.pow(fbNorm, 0.72); // ≈0.58..0.90

    // Auto HF damping: longer tail = darker (prevents "fizz")
    // Bloom modulates HF survival: positive bloom = more air at long tails
    const baseDampFreq = 8000 * Math.pow(0.12, fbNorm); // 8kHz -> ~960Hz
    const bloomDampAdjust = 1.0 + bloom * 0.4; // 0.6x to 1.4x
    const dampFreq = baseDampFreq * bloomDampAdjust;

    // As tail increases, slightly relax modal gain to prevent resonant build-up
    const modalTrimDb = -2.0 * fbNorm; // 0 to -2 dB
    for (let k=0; k<humFilters.length; k++){
      const baseGain = 2.5;
      humFilters[k].gain.setTargetAtTime(baseGain + modalTrimDb, now, 0.12);
    }

    // Smooth tail changes (slower than other params)
    const tailTime = 0.45; // 450ms for smooth tail drags
    for (let i=0; i<humFeedbackGains.length; i++){
      humFeedbackGains[i].gain.setTargetAtTime(feedbackAmount, now, tailTime);
      humDampFilters[i].frequency.setTargetAtTime(dampFreq, now, tailTime);
    }
  }catch(e){
    console.warn('[HUM] applyHumParams error:', e);
  }
}
applyHumParams();


/* ===== E01: Harmonic Bias (phrase-scale drift) =====
   - No UI (yet)
   - Drives Hum base very subtly *only* when Hum Follow is ON
   - One full cycle every `harmonicBiasBars` bars (default 32) */
let __hbLast = 999;

function __computeHarmonicBias(){
  const bpm = (typeof tempo === 'number' && tempo > 0) ? tempo : 120;
  const barSec = (60 / bpm) * 4;
  const period = Math.max(barSec * 4, barSec * (harmonicBiasBars || 32));
  const t = (audioCtx && typeof audioCtx.currentTime === 'number') ? audioCtx.currentTime : 0;
  harmonicBias = Math.sin((2 * Math.PI * t) / period);
  return harmonicBias;
}

// Call periodically while playing; reuses applyHumParams smoothing
function __updateHarmonicBias(){
  const hb = __computeHarmonicBias();
  if (Math.abs(hb - __hbLast) > 0.002){
    __hbLast = hb;
    try { applyHumParams(); } catch(_){}
  }
}


/* ===== Reverse Ghost (prewired tap pool) ===== */
const ghostIn = audioCtx.createGain();
const ghostRevWet = audioCtx.createGain();  ghostRevWet.gain.value = 0.8;

// Gentle safety limiter for ghost spikes (K6)
const ghostComp = audioCtx.createDynamicsCompressor();
ghostComp.threshold.value = -3;   // only catches extreme spikes
ghostComp.knee.value = 6;         // soft knee
ghostComp.ratio.value = 2;        // gentle 2:1
ghostComp.attack.value = 0.003;   // 3ms - fast for transients
ghostComp.release.value = 0.05;   // 50ms - quick recovery

const ghostOut = audioCtx.createGain(); ghostOut.gain.value = 1.0;
const ghostConvolver = audioCtx.createConvolver(); ghostConvolver.normalize=false; ghostConvolver.buffer = makeNoisyIR(audioCtx, 1.8, 0.9995);
function makeAP(ms){ const d=audioCtx.createDelay(0.1); d.delayTime.value=ms/1000; const g=audioCtx.createGain(); g.gain.value=0.5; const inp=audioCtx.createGain(); const sum=audioCtx.createGain(); inp.connect(d); inp.connect(sum); d.connect(g); g.connect(sum); return { in: inp, out: sum }; }
const gAP = makeAP(9);
const ghostStageMix = audioCtx.createGain();
ghostStageMix.connect(ghostRevWet).connect(ghostComp).connect(ghostOut).connect(ghostRouteSplit);
ghostRouteSplit.connect(busSum); // Default: always send to master

/* Tap pool to avoid dynamic connect/disconnect (Chrome-safe) */
const GHOST_TAPS = 12;
let ghostTapIdx = 0;
const ghostTaps = [];
for (let i=0;i<GHOST_TAPS;i++){
  const d = audioCtx.createDelay(3.0);
  const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.Q.value = 3.0;  // reduced from 3.5 (K6)
  const ap = audioCtx.createBiquadFilter(); ap.type='allpass';
  const tap = audioCtx.createGain(); tap.gain.value = 0.0; // gated
  const mix = audioCtx.createGain(); mix.gain.value = 0.0;
  ghostIn.connect(d).connect(bp).connect(ap).connect(tap);
  tap.connect(gAP.in);
  tap.connect(ghostConvolver);
  gAP.out.connect(mix).connect(ghostStageMix);
  ghostConvolver.connect(mix);
  ghostTaps.push({d,bp,ap,tap,mix});
}



/* ===== Morph wet limiter (Ring/Spectral safety) ===== */
const morphWetIn = audioCtx.createGain();
const morphComp = audioCtx.createDynamicsCompressor();
morphComp.threshold.value = -14; morphComp.knee.value = 10; morphComp.ratio.value = 6;
morphComp.attack.value = 0.003; morphComp.release.value = 0.08;
const morphSat = audioCtx.createWaveShaper(); morphSat.curve = makeTanhCurve(0.7);
const morphOut = audioCtx.createGain(); morphOut.gain.value = 1.0;
morphWetIn.connect(morphComp).connect(morphSat).connect(morphOut).connect(dryGain);



/* Master path */
// E02: Stereo silencer gates with independent L/R control for pan timing offset
const silenceSplitter = audioCtx.createChannelSplitter(2);
const silenceGateL = audioCtx.createGain(); silenceGateL.gain.value = 1.0;
const silenceGateR = audioCtx.createGain(); silenceGateR.gain.value = 1.0;
const silenceMerger = audioCtx.createChannelMerger(2);
dryGain.connect(busSum);
busSum.connect(comp).connect(postLimiter).connect(silenceSplitter);
silenceSplitter.connect(silenceGateL, 0).connect(silenceMerger, 0, 0);
silenceSplitter.connect(silenceGateR, 1).connect(silenceMerger, 0, 1);
silenceMerger.connect(outGain).connect(audioCtx.destination);
// Legacy reference for compatibility
const silenceGate = silenceGateL;



// Dev hook: brief, click-free master duck for validation
window.testSilenceGate = function(){
  const now = audioCtx.currentTime;
  try { audioCtx.resume && audioCtx.resume(); } catch(_){}
  if (!window.silenceGate || !silenceGate.gain) return;
  silenceGate.gain.cancelAndHoldAtTime(now);
  silenceGate.gain.setValueAtTime(silenceGate.gain.value, now);
  silenceGate.gain.linearRampToValueAtTime(0.0, now + 0.003);
  silenceGate.gain.setValueAtTime(0.0, now + 0.043);
  silenceGate.gain.linearRampToValueAtTime(1.0, now + 0.063);
};

/* ===== Effect Routing References (created after all effects exist) ===== */
// Effect input references (for routing)
const effectInputs = {
  maja: majaIn,
  dub: delayIn,
  ghost: ghostIn,
  hum: humIn,
  hg: hgIn
};

// Effect split references (for routing)
const effectSplits = {
  maja: majaRouteSplit,
  dub: dubRouteSplit,
  ghost: ghostRouteSplit,
  hum: humRouteSplit,
  hg: hgRouteSplit
};

/* Maja LFO - Unipolar (0 to 1) with DC offset */
const majaLFO = audioCtx.createOscillator(); majaLFO.type='sine';
const majaLFO_Offset = audioCtx.createConstantSource(); majaLFO_Offset.offset.value = 1.0; // DC offset
const majaLFO_Sum = audioCtx.createGain(); majaLFO_Sum.gain.value = 0.5; // Scale (sine + offset) to 0-1 range

// F18: Modulation smoother - removes "zipper noise" from audio-rate coefficient recalculation
const majaLfoSmoother = audioCtx.createBiquadFilter();
majaLfoSmoother.type = 'lowpass';
majaLfoSmoother.frequency.value = 40; // 20-60Hz range suggested; 40Hz is sweet spot
majaLfoSmoother.Q.value = 0.7;

const majaLfoAmt = audioCtx.createGain(); majaLfoAmt.gain.value = 0;

// Signal: sine(-1 to +1) + 1.0 = (0 to 2), then *0.5 = (0 to 1), then smooth, then scale
majaLFO.connect(majaLFO_Sum);
majaLFO_Offset.connect(majaLFO_Sum);
majaLFO_Sum.connect(majaLfoSmoother); // F18: Route through smoother
majaLfoSmoother.connect(majaLfoAmt);  // F18: Then to amount gain

majaLFO.start();
majaLFO_Offset.start();


/* ===== Recorder (post-FX) with fallback ===== */
let recorderMode = null; // 'worklet' | 'script'
let recNode = null, scriptProc = null;
let isRecording = false;
let recBuffersL = [], recBuffersR = [], recLength = 0, recSampleRate = audioCtx.sampleRate;

const workletCode = `
class RecorderProcessor extends AudioWorkletProcessor {
  constructor(){ super(); this.recording=false; this.port.onmessage=e=>this.recording=(e.data==='record'); }
  process(inputs){ const chs=inputs[0]; if(!chs||!chs.length) return true;
    if(this.recording){const L=chs[0]||new Float32Array(128); const R=chs[1]||chs[0]||new Float32Array(128);
      this.port.postMessage({L,R}); }
    return true; }
}
registerProcessor('recorder-processor', RecorderProcessor);
`;

async function ensureRecorder(){
  if (recNode || scriptProc) return;

  if (audioCtx.audioWorklet && typeof AudioWorkletNode !== 'undefined'){
    try{
      const blob = new Blob([workletCode], {type:'application/javascript'});
      const url = URL.createObjectURL(blob);
      await audioCtx.audioWorklet.addModule(url);
      recNode = new AudioWorkletNode(audioCtx, 'recorder-processor', { numberOfInputs:1, numberOfOutputs:0, channelCount:2 });
      outGain.connect(recNode);
      recNode.port.onmessage = (e)=>{ const {L,R}=e.data; recBuffersL.push(new Float32Array(L)); recBuffersR.push(new Float32Array(R)); recLength += L.length; };
      recorderMode = 'worklet';
      return;
    }catch(err){
      console.warn('Worklet recorder unavailable; falling back:', err);
    }
  }

  // Fallback ScriptProcessor (kept alive by silent sink)
  scriptProc = audioCtx.createScriptProcessor(4096, 2, 2);
  const tapGain = audioCtx.createGain(); tapGain.gain.value = 1.0;
  outGain.connect(tapGain).connect(scriptProc);
  scriptProc.onaudioprocess = (e)=>{
    if (!isRecording) return;
    const inL = e.inputBuffer.getChannelData(0);
    const inR = e.inputBuffer.numberOfChannels>1 ? e.inputBuffer.getChannelData(1) : inL;
    recBuffersL.push(new Float32Array(inL));
    recBuffersR.push(new Float32Array(inR));
    recLength += inL.length;
  };
  const nullOut = audioCtx.createGain(); nullOut.gain.value = 0.0;
  scriptProc.connect(nullOut); nullOut.connect(audioCtx.destination);

  recorderMode = 'script';
}

function startWavRecording(){
  recBuffersL=[]; recBuffersR=[]; recLength=0; recSampleRate=audioCtx.sampleRate; isRecording=true;
  if (recorderMode === 'worklet'){ recNode.port.postMessage('record'); }
}
function stopWavRecording(){
  isRecording=false;
  const inter = interleave(merge(recBuffersL,recLength), merge(recBuffersR,recLength));
  const wav = encodeWAV(inter, recSampleRate, 2);
  return new Blob([wav], {type:'audio/wav'}); }


/* ===== State / Sequencing ===== */
// UI mirror (single source of truth from scheduler; preallocate, no per-tick alloc)
if (typeof window !== 'undefined') {
  window.ui = window.ui || {};
  if (!window.ui.stepLocal || (window.ui.stepLocal.length|0) !== ((typeof NUM_SOUNDS!=='undefined'?NUM_SOUNDS:9)|0)) {
    window.ui.stepLocal = new Int32Array((typeof NUM_SOUNDS!=='undefined'?NUM_SOUNDS:9)|0);
  }
  if (typeof window.ui.playPg !== 'number') window.ui.playPg = 0;
}

// Phase alignment for Link Mode: keeps 'one' stationary on toggle
if (typeof window !== 'undefined' && typeof window.chainPhase === 'undefined') window.chainPhase = 0;

// Phase 4: per-track scheduler playheads (CR-021b)
let playhead = new Array(NUM_SOUNDS).fill(0);
if (typeof window !== 'undefined') window.playheadRef = playhead; // expose to UI safely
function resetPlayheads() {
  try {
    const N = (typeof N_STEPS !== 'undefined' ? N_STEPS : 16);
    for (let ch = 0; ch < NUM_SOUNDS; ch++) {
      const L = Math.max(1, (trackLen && (trackLen[ch]|0)) || N);
      playhead[ch] = 0 % L;
    }
  } catch(_) {}
}

// Phase 4 helper: per-track local step (safe no-op for now)
function getLocalStep(ch, globalStep){
  try{
    const N = (typeof N_STEPS !== 'undefined' ? N_STEPS : 16);
    const L = Math.max(1, (trackLen && (trackLen[ch]|0)) || N);
    return (globalStep % L) | 0;
  }catch(_){ return globalStep|0; }
}

// Phase 4: per-track loop lengths
const trackLen = new Array(SOUND_NAMES.length).fill(16);
function applyTrackLenUI(ch){
  try{
    const row = document.querySelector(`[data-row='${ch}']`);
    if(!row) return;
    const stepsEl = row.querySelector('.steps') || row.querySelector('.stepsCol');
    if(!stepsEl) return;
    const boxes = stepsEl.querySelectorAll('.step');
    const L = trackLen[ch]|0;
    boxes.forEach((box,i)=>{ if(i>=L) box.classList.add('dim'); else box.classList.remove('dim'); });
  }catch(_){}
}

let tempo = 120, isPlaying = false, currentStep = 0, nextNoteTime = 0, rafId;
let absStep = 0; // absolute step counter for Chain mode
let pattern = Array.from({length:NUM_SOUNDS},()=>Array(MAX_STEPS).fill(false));
let probability = Array.from({length:NUM_SOUNDS},()=>Array(MAX_STEPS).fill(1));
let hitCounters = Array.from({length:NUM_SOUNDS},()=>Array(MAX_STEPS).fill(0));
function resetHitCounters(){
  for (let s=0; s<NUM_SOUNDS; s++){
    for (let st=0; st<MAX_STEPS; st++) hitCounters[s][st] = 0;
  }
}

let morphTarget = Array.from({length:NUM_SOUNDS},()=>Array(MAX_STEPS).fill(0));
let morphAmt = Array.from({length:NUM_SOUNDS},()=>Array(MAX_STEPS).fill(0));
let timingOffsetMs = Array.from({length:NUM_SOUNDS},()=>Array(MAX_STEPS).fill(0));
let stepPitch = Array.from({length:NUM_SOUNDS},()=>Array(MAX_STEPS).fill(0)); // B07: Pitch per hit (semitones)
let pitches = new Array(NUM_SOUNDS).fill(1.0);
let adsr = Array.from({length:NUM_SOUNDS}, (_, i) => {
  const silencerIdx = SOUND_NAMES.indexOf("Silencer");
  return i === silencerIdx
    ? {a:0.015, d:0.010, s:0.20, r:0.025}  // E05: Silencer tight ranges: A:15ms, D:10ms, S:0.20, R:25ms
    : {a:0.02, d:0.25, s:1.0, r:0.25}; // Other tracks: s=1.0 for full volume
});

/* F17: Harmonic Framework moved earlier (see line ~1196) to fix initialization order */
// Per-track quantization enabled (default: off to preserve existing workflow)
let trackQuantizeEnabled = new Array(NUM_SOUNDS).fill(false);

// G09: Per-track diatonic mode (scale degrees instead of chromatic semitones)
let diatonicEnabled = new Array(NUM_SOUNDS).fill(false);

// G11: Store references to pitch dropdowns for dynamic rebuilding
// pitchDropdowns[trackIdx][stepIdx] = select element
let pitchDropdowns = Array.from({length:NUM_SOUNDS},()=>Array(MAX_STEPS).fill(null));

/* ===== B04: Solo state for tracks ===== */
// Solo functionality: double-click volume slider to solo a track
// When any track(s) are soloed, only soloed tracks play (ignores mute state)
// When no tracks are soloed, all tracks play according to mute state
let soloState = new Array(NUM_SOUNDS).fill(false);

/* ===== A3: Per-track polyrhythm counters ===== */
let trackStepCounter = new Array(NUM_SOUNDS).fill(0);  // Independent step counter per track
let trackCumulativeLen = new Array(NUM_SOUNDS).fill(16); // Cumulative length across all pages

// H09: Removed updateDebugDisplay() - debug counter display removed

// Calculate cumulative rail lengths when chain mode is on
function calcCumulativeLengths() {
  if (!window.chainMode || pageCount <= 1) {
    // No chain mode: each track uses its current page rail length
    for (let t = 0; t < NUM_SOUNDS; t++) {
      trackCumulativeLen[t] = trackLen[t] || 16;
    }
  } else {
    // Chain mode: sum rail lengths across all pages
    for (let t = 0; t < NUM_SOUNDS; t++) {
      let total = 0;
      for (let pg = 0; pg < pageCount; pg++) {
        // A6: Use current trackLen for current page, scenes data for others
        let pageRailLen;
        if (pg === currentPage) {
          pageRailLen = trackLen[t] || 16;
        } else {
          const pageData = scenes[pg];
          pageRailLen = (pageData && pageData.trackLen && pageData.trackLen[t]) || 16;
        }
        // I12: Multiply by page repeat count
        const repeatCount = pageRepeatCounts[pg] || 1;
        total += pageRailLen * repeatCount;
      }
      trackCumulativeLen[t] = Math.max(1, total);
    }
  }
  // H09: Removed updateDebugDisplay() call
}

// A7: Map track counter to page/step for polyrhythm
function getTrackPosition(trackIdx) {
  const counter = trackStepCounter[trackIdx];
  const usingChain = !!window.chainMode && (pageCount|0) > 1;

  // B02: Phrase track is constant across all pages - use rail length for loop
  if (trackIdx === PHRASES_IDX) {
    const phraseRailLen = trackLen[PHRASES_IDX] || 16;
    const localStep = counter % phraseRailLen;
    // globalStep is 0-15 for pattern array access, page is currentPage for cursor display
    return { page: currentPage, localStep, globalStep: localStep };
  }

  if (!usingChain) {
    // Simple case: single page, use current page
    const localStep = counter % 16;
    const globalStep = currentPage * 16 + localStep;
    return { page: currentPage, localStep, globalStep };
  }

  // Chain mode: find which page this counter position is on
  let accumulated = 0;
  for (let pg = 0; pg < pageCount; pg++) {
    // Get rail length for this page
    let pageRailLen;
    if (pg === currentPage) {
      pageRailLen = trackLen[trackIdx] || 16;
    } else {
      const pageData = scenes[pg];
      pageRailLen = (pageData && pageData.trackLen && pageData.trackLen[trackIdx]) || 16;
    }

    // I12: Account for page repeats
    const repeatCount = pageRepeatCounts[pg] || 1;
    const totalPageLen = pageRailLen * repeatCount;

    if (counter < accumulated + totalPageLen) {
      // Counter is on this page (accounting for repeats)
      const posInRepeats = counter - accumulated;
      const localStep = posInRepeats % pageRailLen;
      const globalStep = pg * 16 + localStep;
      return { page: pg, localStep, globalStep };
    }

    accumulated += totalPageLen;
  }

  // Fallback (shouldn't happen)
  return { page: 0, localStep: 0, globalStep: 0 };
}

/* ===== Phase 7: Scenes (UI-only) ===== */
const MAX_PAGES = 4;
let scenes = [];   // array of page snapshots
let pageCount = 1;
let currentPage = 0;

// I12: Page repeat counts for link/chain mode (1-8)
let pageRepeatCounts = [1, 1, 1, 1]; // Default 1 repeat per page

function clone2D(a){ return a.map(row => row.slice()); }
function snapshotFromGlobals(){
  // A1: Only save trackLen per page (pattern data is now unified across all pages)
  return {
    trackLen: trackLen.slice(0)
  };
}
function loadGlobalsFromSnapshot(pg){
  const p = scenes[pg];
  if (!p) return;
  // A1: Only restore trackLen (pattern data is unified, just refresh UI)
  // I05 FIX: Skip PHRASES_IDX - phrase track rail length is constant across all pages
  // trackLen is a const array; copy into it
  for (let i=0;i<trackLen.length && i<p.trackLen.length;i++){
    if (i === PHRASES_IDX) continue; // I05: Phrase track constant across pages
    trackLen[i] = p.trackLen[i];
  }
  refreshGridFromArrays();
  if (typeof applyAllTrackLenUI==='function') applyAllTrackLenUI();
  try{ window.dispatchEvent(new Event('resize')); }catch(_){}
  try{ if (typeof highlight==='function') highlight(typeof currentStep!=='undefined'?currentStep:0); }catch(_){}
}
function saveGlobalsIntoScene(pg){ scenes[pg] = snapshotFromGlobals(); }

/* Chain helpers: get page data and show playing indicator */
function getPageData(pg){
  // A1: Pattern data is unified across all pages, only trackLen differs per page
  const s = scenes[pg];
  // I05 FIX: Phrase track rail length is constant - always use current value
  const pageTrackLen = (s && s.trackLen) ? s.trackLen.slice(0) : trackLen.slice(0);
  if (typeof PHRASES_IDX !== 'undefined') {
    pageTrackLen[PHRASES_IDX] = trackLen[PHRASES_IDX]; // Always use current phrase rail length
  }
  return { pattern, probability, morphTarget, morphAmt, timingOffsetMs, trackLen: pageTrackLen };
}
function updatePlayingIndicator(pg){
  try{
    for (let i=0;i<4;i++){ const b = document.getElementById('sceneBtn'+(i+1)); if (!b) continue; b.classList.toggle('playing', i===pg); }
  }catch(_){}
}
function updateSceneBar(){
  try{
    const btns = [0,1,2,3].map(i=>document.getElementById('sceneBtn'+(i+1)));
    for (let i=0;i<btns.length;i++){
      const b = btns[i]; if(!b) continue;
      b.classList.toggle('inactive', i >= pageCount);
      b.classList.toggle('active', i === currentPage);
    }
    const prev = document.getElementById('scenePrev'); const next = document.getElementById('sceneNext'); const add = document.getElementById('sceneAdd');
    if (prev) prev.disabled = (currentPage <= 0);
    if (next) next.disabled = (currentPage >= pageCount-1);
    if (add)  add.disabled  = (pageCount >= MAX_PAGES);
  }catch(_){}
}
function applyAllTrackLenUI(){ try{ for (let s=0; s<NUM_SOUNDS; s++) applyTrackLenUI(s); }catch(_){ } }
function refreshGridFromArrays(){
  try{
    const stepOffset = currentPage * N_STEPS; // A1: Map page to step range
    const rows = document.querySelectorAll('.grid .track');
    rows.forEach((row, s)=>{
      const stepsEl = row.querySelector('.steps'); if (!stepsEl) return;
      const cells = stepsEl.querySelectorAll('.step');
      for (let st=0; st<N_STEPS; st++){
        const cell = cells[st]; if (!cell) continue;
        // A12: Phrase track is constant across pages - always use steps 0-15
        const globalStep = (s === PHRASES_IDX) ? st : (stepOffset + st);
        const hit = cell.querySelector('.hit'); if (hit) hit.classList.toggle('active', !!(pattern[s] && pattern[s][globalStep]));
        const probEl = cell.querySelector('input[data-param="interval"]'); if (probEl && probability[s]) probEl.value = probability[s][globalStep]; // B17: Fixed selector
        const selEl  = cell.querySelector('select[title="Morph To"]'); if (selEl && morphTarget[s]) selEl.value = String(morphTarget[s][globalStep]);
        const amtEl  = cell.querySelector('input[title="Morph Amount"]'); if (amtEl && morphAmt[s]) amtEl.value = morphAmt[s][globalStep];
        const tEl    = cell.querySelector('input[title="Timing (ms)"]'); if (tEl && timingOffsetMs[s]) tEl.value = timingOffsetMs[s][globalStep];

        // G11: Rebuild pitch dropdown options based on diatonic mode, then set value
        const pEl = cell.querySelector('select[title="Pitch Shift"]');
        if (pEl && stepPitch[s]) {
          const currentValue = stepPitch[s][globalStep];
          pEl.innerHTML = generatePitchOptions(s, currentValue);
          // G17: Normalize value before setting (degree 0 → degree 1 in diatonic mode)
          const normalizedValue = (diatonicEnabled[s] && currentValue === 0) ? 1 : currentValue;
          pEl.value = String(normalizedValue);
          // Store reference for diatonic toggle
          pitchDropdowns[s][st] = pEl;
        }
      }
      applyTrackLenUI(s);
    });
  }catch(_){}
}
/* Clear current page: hits only */
function clearCurrentPage(){
  try{
    const stepOffset = currentPage * N_STEPS; // A1: Map page to step range
    for (let s=0; s<NUM_SOUNDS; s++){
      // A12: Skip phrase track - it's constant across all pages
      if (s === PHRASES_IDX) continue;
      for (let st=0; st<N_STEPS; st++){
        const globalStep = stepOffset + st; // A1: Global step index
        if (pattern[s]) pattern[s][globalStep] = false;
      }
    }
    refreshGridFromArrays();
    if (typeof highlight==='function') highlight(typeof currentStep!=='undefined'?currentStep:0);
    if (typeof saveGlobalsIntoScene==='function') saveGlobalsIntoScene(currentPage|0);
  }catch(_){}
}
function initScenesUI(){
  scenes = [ snapshotFromGlobals() ];
  pageCount = 1; currentPage = 0;
  updateSceneBar();

  const selPage = (pg)=>{ if (pg<0||pg>=pageCount) return; saveGlobalsIntoScene(currentPage); currentPage = pg; loadGlobalsFromSnapshot(currentPage); updateSceneBar(); };

  // B06: Enhanced addPage - copyPattern flag controls whether to duplicate current page's pattern
  const addPage = (copyPattern = false)=>{
    if (pageCount>=MAX_PAGES) return;
    saveGlobalsIntoScene(currentPage);

    // B06: If copyPattern is true, copy current page's pattern data to new page's steps
    if (copyPattern) {
      const srcOffset = currentPage * N_STEPS;  // Current page's step offset
      const dstOffset = pageCount * N_STEPS;    // New page's step offset

      // Copy all pattern data for all tracks
      for (let s = 0; s < NUM_SOUNDS; s++) {
        // A12: Skip phrase track - it's constant across all pages
        if (s === PHRASES_IDX) continue;
        for (let st = 0; st < N_STEPS; st++) {
          const srcIdx = srcOffset + st;
          const dstIdx = dstOffset + st;

          // Copy hit pattern
          if (pattern[s]) pattern[s][dstIdx] = pattern[s][srcIdx];

          // Copy probability/interval
          if (probability[s]) probability[s][dstIdx] = probability[s][srcIdx];

          // Copy morph target
          if (morphTarget[s]) morphTarget[s][dstIdx] = morphTarget[s][srcIdx];

          // Copy morph amount
          if (morphAmt[s]) morphAmt[s][dstIdx] = morphAmt[s][srcIdx];

          // Copy timing offset
          if (timingOffsetMs[s]) timingOffsetMs[s][dstIdx] = timingOffsetMs[s][srcIdx];

          // B08: Copy pitch per hit
          if (stepPitch[s]) stepPitch[s][dstIdx] = stepPitch[s][srcIdx];
        }
      }
    }

    scenes[pageCount] = snapshotFromGlobals();
    // I12: Initialize repeat count for new page
    pageRepeatCounts[pageCount] = 1;
    pageCount++;
    currentPage = pageCount-1;
    loadGlobalsFromSnapshot(currentPage);
    updateSceneBar();
    // I12: Update page button displays
    for (let i = 0; i < pageCount; i++) {
      updatePageButtonDisplay(i);
    }
    // D10: Recalculate cumulative lengths so new page is included in Link Mode loop
    if (typeof calcCumulativeLengths === 'function') calcCumulativeLengths();
  };

  // G02: Remove current page function (fixed syncing issues)
  const removePage = () => {
    // Can't remove the last page - need at least one
    if (pageCount <= 1) return;

    const pageToRemove = currentPage;

    // Shift all higher pages down by one page (16 steps)
    for (let pg = pageToRemove; pg < pageCount - 1; pg++) {
      const srcOffset = (pg + 1) * N_STEPS;  // Source: next page
      const dstOffset = pg * N_STEPS;        // Destination: current page

      // Copy all data from next page to current page
      for (let s = 0; s < NUM_SOUNDS; s++) {
        for (let st = 0; st < N_STEPS; st++) {
          const srcIdx = srcOffset + st;
          const dstIdx = dstOffset + st;

          // Copy all arrays
          if (pattern[s]) pattern[s][dstIdx] = pattern[s][srcIdx];
          if (probability[s]) probability[s][dstIdx] = probability[s][srcIdx];
          if (morphTarget[s]) morphTarget[s][dstIdx] = morphTarget[s][srcIdx];
          if (morphAmt[s]) morphAmt[s][dstIdx] = morphAmt[s][srcIdx];
          if (timingOffsetMs[s]) timingOffsetMs[s][dstIdx] = timingOffsetMs[s][srcIdx];
          if (stepPitch[s]) stepPitch[s][dstIdx] = stepPitch[s][srcIdx];
        }
      }

      // Copy scene snapshot
      if (scenes[pg + 1]) {
        scenes[pg] = scenes[pg + 1];
      }
      // I12: Shift repeat counts
      pageRepeatCounts[pg] = pageRepeatCounts[pg + 1] || 1;
    }

    // G02: Clear the old last page's data (now unused after shift) to prevent syncing issues
    const oldLastPageOffset = (pageCount - 1) * N_STEPS;
    for (let s = 0; s < NUM_SOUNDS; s++) {
      for (let st = 0; st < N_STEPS; st++) {
        const idx = oldLastPageOffset + st;
        // Reset to defaults
        if (pattern[s]) pattern[s][idx] = false;
        if (probability[s]) probability[s][idx] = 1;
        if (morphTarget[s]) morphTarget[s][idx] = 0;
        if (morphAmt[s]) morphAmt[s][idx] = 0;
        if (timingOffsetMs[s]) timingOffsetMs[s][idx] = 0;
        if (stepPitch[s]) stepPitch[s][idx] = 0;
      }
    }

    // Clear scene snapshot for old last page
    scenes[pageCount - 1] = null;
    // I12: Reset repeat count for removed page
    pageRepeatCounts[pageCount - 1] = 1;

    // Decrement page count
    pageCount--;

    // Adjust current page if needed
    if (currentPage >= pageCount) {
      currentPage = pageCount - 1;
    }

    // Reload current page and update UI
    loadGlobalsFromSnapshot(currentPage);
    updateSceneBar();
    refreshGridFromArrays();
    // I12: Update page button displays
    for (let i = 0; i < pageCount; i++) {
      updatePageButtonDisplay(i);
    }
    // D10: Recalculate cumulative lengths so removed page is excluded from Link Mode loop
    if (typeof calcCumulativeLengths === 'function') calcCumulativeLengths();
  };

  const prev = document.getElementById('scenePrev'); if (prev) prev.addEventListener('click', ()=> selPage(currentPage-1));
  const next = document.getElementById('sceneNext'); if (next) next.addEventListener('click', ()=> selPage(currentPage+1));

  // B06: Add page button with shift-key detection
  const add  = document.getElementById('sceneAdd');
  if (add) {
    add.addEventListener('click', (e) => {
      const copyPattern = e.shiftKey;  // Shift+click copies pattern
      addPage(copyPattern);
    });
  }

  // G01: Remove page button
  const remove = document.getElementById('sceneRemove');
  if (remove) {
    remove.addEventListener('click', () => {
      removePage();
    });
  }

  // I12: Update page button display with superscript for repeat count
  function updatePageButtonDisplay(pageIdx) {
    const b = document.getElementById('sceneBtn'+(pageIdx+1));
    if (!b) return;
    const repeatCount = pageRepeatCounts[pageIdx] || 1;
    const baseText = String(pageIdx + 1);

    if (repeatCount > 1 && window.chainMode) {
      // Use Unicode superscript characters
      const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹'];
      const superscript = String(repeatCount).split('').map(d => superscripts[parseInt(d)]).join('');
      b.textContent = baseText + superscript;
    } else {
      b.textContent = baseText;
    }
  }

  // I12: Page button click handler - cycles repeat count if already active, otherwise selects page
  for (let i=0;i<4;i++){
    const b = document.getElementById('sceneBtn'+(i+1));
    if (b) {
      b.addEventListener('click', ()=> {
        if (i === currentPage && window.chainMode) {
          // Already on this page and chain mode is active - cycle repeat count
          pageRepeatCounts[i] = pageRepeatCounts[i] >= 8 ? 1 : (pageRepeatCounts[i] + 1);
          updatePageButtonDisplay(i);
          calcCumulativeLengths(); // Recalculate lengths when repeat count changes
        } else {
          // Switch to this page
          selPage(i);
        }
      });
    }
  }

  // Chain UI (UI-only for now)
  window.chainMode = false;
  const chainBtn = document.getElementById('chainBtn');
  function updateChainUI(){
    if (chainBtn) chainBtn.classList.toggle('active', !!window.chainMode);
    // I12: Update all page button displays when chain mode changes
    for (let i = 0; i < pageCount; i++) {
      updatePageButtonDisplay(i);
    }
  }
  if (chainBtn){ chainBtn.addEventListener('click', ()=>{
      const wasChainMode = window.chainMode;
      window.chainMode = !window.chainMode;
      // I12: Reset repeat counts to 1 when turning chain mode off
      if (wasChainMode && !window.chainMode) {
        pageRepeatCounts = [1, 1, 1, 1];
      }
      try {
        var Nloc = (typeof N_STEPS !== 'undefined' ? N_STEPS : 16);
        var P = (pageCount|0);
        if (window.chainMode) {
          // D11: Only calculate phase offset if currently playing; otherwise start clean
          if (isPlaying) {
            var curLocal = (typeof currentStep !== 'undefined') ? (currentStep|0) : 0;
            var curAbs = (typeof absStep !== 'undefined') ? (absStep|0) : 0;
            var qPg = Math.floor(curAbs / Nloc) % (P||1);
            var cp = (currentPage|0);
            var offPages = (((qPg - cp) % (P||1)) + (P||1)) % (P||1);
            window.chainPhase = (((curAbs % Nloc) - (curLocal % Nloc)) + (offPages * Nloc)) | 0;
          } else {
            window.chainPhase = 0;
          }
        } else {
          window.chainPhase = 0;
        }
      } catch(_) {}
      // A3: Recalculate cumulative lengths when chain mode changes
      calcCumulativeLengths();
updateChainUI(); }); updateChainUI(); }

  // Keyboard: 1-4 / numpad 1-4 / arrows / Shift+= (= +) to add / D for debug
  window.addEventListener('keydown', (e)=>{
    if (e.target && ['INPUT','SELECT','TEXTAREA'].includes((e.target.tagName||'').toUpperCase())) return;
    const k = e.key;
    if (k>='1' && k<='4'){ const idx = (k.charCodeAt(0) - '1'.charCodeAt(0)); if (idx < pageCount){ selPage(idx); e.preventDefault(); } return; }
    if (e.code==='Numpad1' || e.code==='Numpad2' || e.code==='Numpad3' || e.code==='Numpad4'){ const idx = (+k)-1; if (idx < pageCount){ selPage(idx); e.preventDefault(); } return; }
    if (k==='ArrowLeft'){ selPage(currentPage-1); e.preventDefault(); return; }
    if (k==='ArrowRight'){ selPage(currentPage+1); e.preventDefault(); return; }
    // B06: '+' adds blank page, Shift+'=' copies current page pattern
    if ((k==='+') || (k==='=' && e.shiftKey)){ addPage(e.shiftKey); e.preventDefault(); return; }
    // H09: Removed D key debug counter toggle
  }, {passive:false});
}


/* Per-track mixer nodes: Trim (fader) -> Tone Low/High -> Split */
const trackIn = [], trackTrim = [], toneLo = [], toneHi = [], trackSplit = [];
/* Per-track pan nodes */
const panNode = [];
/* Per-track sends */
const majaSendGains = Array.from({length:NUM_SOUNDS}, ()=>audioCtx.createGain());
const delaySendGains = Array.from({length:NUM_SOUNDS}, ()=>audioCtx.createGain());
const ghostSendGains = Array.from({length:NUM_SOUNDS}, ()=>audioCtx.createGain());

const humSendGains = Array.from({length:NUM_SOUNDS}, ()=>audioCtx.createGain());
const hgSendGains = Array.from({length:NUM_SOUNDS}, ()=>audioCtx.createGain());
// D16: ConstantSource for audio-rate volume smoothing (eliminates zipper noise)
const volControlSources = Array.from({length:NUM_SOUNDS}, ()=>audioCtx.createConstantSource());
for (let i=0;i<NUM_SOUNDS;i++){
  trackIn[i] = audioCtx.createGain();
  trackTrim[i] = audioCtx.createGain(); trackTrim[i].gain.value = 0; // Controlled by ConstantSource
  // D16: Wire ConstantSource to trackTrim.gain for audio-rate smoothing
  volControlSources[i].offset.value = 1.0; // 0 dB default
  volControlSources[i].connect(trackTrim[i].gain);
  volControlSources[i].start();
  toneLo[i] = audioCtx.createBiquadFilter(); toneLo[i].type='lowshelf'; toneLo[i].frequency.value = 300;
  toneHi[i] = audioCtx.createBiquadFilter(); toneHi[i].type='highshelf'; toneHi[i].frequency.value = 4000;
  trackSplit[i] = audioCtx.createGain(); trackSplit[i].gain.value = 1.0;

  // Stereo pan between trim and tone
  panNode[i] = (audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null);
  if (panNode[i] && panNode[i].pan) { try { panNode[i].pan.value = 0; } catch(_){} }

  // Rewire: trackIn -> trim -> pan -> tone -> tone -> split
  trackIn[i].connect(trackTrim[i]);
  (panNode[i] ? trackTrim[i].connect(panNode[i]) && panNode[i].connect(toneLo[i]) : trackTrim[i].connect(toneLo[i]));
  toneLo[i].connect(toneHi[i]).connect(trackSplit[i]);

  // Split to dry + sends
  trackSplit[i].connect(dryGain);
  trackSplit[i].connect(majaSendGains[i]);
  trackSplit[i].connect(delaySendGains[i]);
  trackSplit[i].connect(ghostSendGains[i]);

  majaSendGains[i].gain.value = 0;
  delaySendGains[i].gain.value = 0;
  ghostSendGains[i].gain.value = 0;

  majaSendGains[i].connect(majaIn);
  delaySendGains[i].connect(delayIn);
  ghostSendGains[i].connect(ghostIn);
      // Hum send
      trackSplit[i].connect(humSendGains[i]);
      humSendGains[i].gain.value = 0.0;
      humSendGains[i].connect(humIn);

  // Harmonic Gate send (PRE-FADER for insert-style behavior)
  trackIn[i].connect(hgSendGains[i]);  // Tap BEFORE volume control
  hgSendGains[i].gain.value = 0.0;
  hgSendGains[i].connect(hgIn);

}

/* Reverse Ghost params */
let ghostLen = 0.8, ghostPitchSemis = 0, ghostBoost = 0.2, ghostDensity = 0.5, ghostReverse = 0.6, ghostOblique = 0, ghostRevWetCtrl = 0.8;
let ghostClockDivision = 4; // F18: quarter notes (1=whole, 2=half, 4=quarter, 8=eighth, 16=sixteenth)
let nextGhostClockTime = 0; // F18: next scheduled clock trigger time
let ghostClockEnabled = false; // F18: true when effect is connected to Ghost

/* Reactive Dub */
let fxReact = 1.2;
// React-driven widener: Haas-effect cross-mixing for stereo width
function applyDubReact(v){
  // Map React 0..2 → 0..1 linearly (no dead zone)
  const amt = Math.max(0, Math.min(1, v / 2.0));

  // Feedback modifier boosts width at higher feedback
  let fbNorm = 0;
  try { const fbEl = document.getElementById('delayFb'); if (fbEl) fbNorm = Math.max(0, Math.min(1, (+fbEl.value||0)/0.6)); } catch(_){}
  const mod = 1 + 0.30 * fbNorm;

  const now = audioCtx.currentTime;

  // Control cross-mix amount (0 = mono, higher = wider)
  // At max React with feedback, cross-gain can reach ~0.65 for dramatic width
  const crossAmt = (amt * 0.5 * mod);  // 0 → 0.65 at extreme

  try {
    // Increase cross-mixing for width
    dubCrossL.gain.setTargetAtTime(crossAmt, now, 0.08);
    dubCrossR.gain.setTargetAtTime(crossAmt, now, 0.08);

    // Modulate allpass frequencies for movement
    const depth = amt * (1 + 0.25 * fbNorm);
    dubAP_L.frequency.setTargetAtTime(2200 + 400*depth, now, 0.2);
    dubAP_R.frequency.setTargetAtTime(1600 + 600*depth, now, 0.2);
  } catch(_){}
}
let fxReactSmooth = fxReact; // CR-025: smoothed reactive FX drive
/* Sample buffers */
const sampleBufs = new Array(NUM_SOUNDS).fill(null);
const sampleMeta = new Array(NUM_SOUNDS).fill(null);

/* ===== Helpers ===== */
function microDrift(){ return 1 + (Math.random()-0.5)*0.02; }
function semisToRatio(semi){ return Math.pow(2, semi/12); }
function dbToGain(db){ return Math.pow(10, db/20); }

// G09: Convert scale degree to chromatic semitones
// degree: 1-based integer (1 = root, 2 = 2nd, 3 = 3rd, etc.)
// Supports multiple octaves: degree 8 in major = root + octave
// Negative degrees go down: -1 = 7th below, etc.
function scaleDegreeToSemitones(degree, rootNote, scaleName) {
  // G18: In diatonic mode, ignore chromatic scale - use major as default
  const actualScaleName = (scaleName === 'chromatic' || !scaleName) ? 'major' : scaleName;
  const scale = scaleDefinitions[actualScaleName] || scaleDefinitions.major;

  // G15: Handle degree 0 as root note (for backwards compatibility)
  if (degree === 0) return rootNote;

  // G17: Separate handling for positive and negative degrees
  if (degree > 0) {
    // Positive degrees: 1 = root, 2 = 2nd, etc.
    const zeroBased = degree - 1;
    const octave = Math.floor(zeroBased / scale.length);
    const degreeIndex = zeroBased % scale.length;
    const intervalInScale = scale[degreeIndex];
    return rootNote + intervalInScale + (octave * 12);
  } else {
    // Negative degrees: -1 = 7th below, -2 = 6th below, etc.
    const positiveDegree = -degree;
    const octave = -Math.ceil(positiveDegree / scale.length);
    const stepsFromBottom = (positiveDegree - 1) % scale.length;
    const degreeIndex = scale.length - 1 - stepsFromBottom;
    const intervalInScale = scale[degreeIndex];
    return rootNote + intervalInScale + (octave * 12);
  }
}

/* H14: Removed testScaleDegrees() debug function - was only for G09 development testing */

// G11: Get note name for a scale degree
// degree: 1-based integer (1=root, 2=2nd, etc.)
// Returns note name like "C", "D", "E", etc. with octave indication if needed
function getScaleDegreeName(degree) {
  const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  // G18: In diatonic mode, ignore chromatic scale - use major as default
  const scaleName = (globalScale === 'chromatic' || !globalScale) ? 'major' : globalScale;
  const scale = scaleDefinitions[scaleName] || scaleDefinitions.major;

  // G14: Return root note name instead of "0" for degree 0
  if (degree === 0) {
    const rootNoteName = noteNames[globalRoot % 12];
    return rootNoteName;
  }

  // G17: Separate handling for positive and negative degrees (matches scaleDegreeToSemitones)
  let octave, degreeIndex;
  if (degree > 0) {
    const zeroBased = degree - 1;
    octave = Math.floor(zeroBased / scale.length);
    degreeIndex = zeroBased % scale.length;
  } else {
    const positiveDegree = -degree;
    octave = -Math.ceil(positiveDegree / scale.length);
    const stepsFromBottom = (positiveDegree - 1) % scale.length;
    degreeIndex = scale.length - 1 - stepsFromBottom;
  }

  // Get the interval and note
  const intervalInScale = scale[degreeIndex];
  const semitonesRaw = globalRoot + intervalInScale + (octave * 12);
  const semitones = ((semitonesRaw % 12) + 12) % 12;
  const noteName = noteNames[semitones];

  // Add octave indicator for degrees beyond the first octave
  if (octave > 0) return noteName + (octave + 1);
  if (octave < 0) return noteName + (octave + 1);
  return noteName;
}

// G11: Generate pitch dropdown options HTML based on diatonic mode
// trackIdx: which track this dropdown is for
// currentValue: currently selected value (to preserve selection)
function generatePitchOptions(trackIdx, currentValue = 0) {
  const isDiatonic = diatonicEnabled[trackIdx];

  if (isDiatonic) {
    // G15: Diatonic mode - one octave up/down, skip degree 0 (duplicate of degree 1)
    // Range: 1 to 7 (root through 7th), then -1 to -7 (one octave down)
    // Map degree 0 to degree 1 (both are root note)
    const normalizedValue = currentValue === 0 ? 1 : currentValue;

    let html = '';
    for (let degree = 7; degree >= 1; degree--) {
      const name = getScaleDegreeName(degree);
      const selected = (degree === normalizedValue) ? ' selected' : '';
      html += `<option value="${degree}"${selected}>${name}</option>\n`; // G16: No prefix
    }
    for (let degree = -1; degree >= -7; degree--) {
      const name = getScaleDegreeName(degree);
      const selected = (degree === normalizedValue) ? ' selected' : '';
      html += `<option value="${degree}"${selected}>${name}</option>\n`;
    }
    return html;
  } else {
    // Chromatic mode: one octave up/down (range: -12 to +12 semitones)
    let html = '';
    for (let semitones = 12; semitones >= -12; semitones--) {
      const selected = (semitones === currentValue) ? ' selected' : '';
      const display = semitones > 0 ? `+${semitones}` : semitones;
      html += `<option value="${semitones}"${selected}>${display}</option>\n`;
    }
    return html;
  }
}

// G11: Rebuild pitch dropdowns for a specific track when diatonic mode toggles
// Only rebuilds the currently visible dropdowns (current page's 16 steps)
// Other pages will be rebuilt automatically by refreshGridFromArrays when loaded
function rebuildPitchDropdownsForTrack(trackIdx) {
  const stepOffset = currentPage * N_STEPS;
  // Rebuild only the visible dropdowns (0-15 for current page)
  for (let st = 0; st < N_STEPS; st++) {
    const dropdown = pitchDropdowns[trackIdx][st];
    if (dropdown) {
      const globalStep = stepOffset + st;
      const currentValue = stepPitch[trackIdx][globalStep] || 0;
      dropdown.innerHTML = generatePitchOptions(trackIdx, currentValue);
      // G19: Normalize value before setting (degree 0 → degree 1 in diatonic mode)
      const normalizedValue = (diatonicEnabled[trackIdx] && currentValue === 0) ? 1 : currentValue;
      dropdown.value = String(normalizedValue);
    }
  }
}

// Quantize pitch to the selected global scale
function quantizePitch(semitones, trackIndex) {
  // If quantization is disabled for this track, or scale is chromatic, return original
  if (!trackQuantizeEnabled[trackIndex] || globalScale === 'chromatic') {
    return semitones;
  }

  // Get the scale intervals
  const scale = scaleDefinitions[globalScale] || scaleDefinitions.chromatic;

  // Normalize semitones to 0-11 range (within one octave)
  const octave = Math.floor(semitones / 12);
  const noteInOctave = semitones - (octave * 12);

  // Find the nearest note in the scale
  let minDistance = Infinity;
  let nearestNote = 0;

  // Check notes in current octave
  for (let i = 0; i < scale.length; i++) {
    const scaleNote = (scale[i] + globalRoot) % 12;
    const distance = Math.abs(noteInOctave - scaleNote);
    if (distance < minDistance) {
      minDistance = distance;
      nearestNote = scaleNote;
    }
  }

  // Also check notes in adjacent octaves to handle wrap-around
  for (let i = 0; i < scale.length; i++) {
    const scaleNote = ((scale[i] + globalRoot) % 12) + 12;
    const distance = Math.abs(noteInOctave - scaleNote);
    if (distance < minDistance) {
      minDistance = distance;
      nearestNote = scaleNote;
    }
  }

  for (let i = 0; i < scale.length; i++) {
    const scaleNote = ((scale[i] + globalRoot) % 12) - 12;
    const distance = Math.abs(noteInOctave - scaleNote);
    if (distance < minDistance) {
      minDistance = distance;
      nearestNote = scaleNote;
    }
  }

  // Return quantized semitones
  return octave * 12 + nearestNote;
}
// ===== ADSR Envelope Functions =====

// Synth ADSR: Simplified for fixed-duration synth voices
// Fixed 1.2s body, uses setTargetAtTime for smooth release
function applySynthADSR(g, time, a, d, s, r, peakAmp=1){
  // Simple attack ramp
  g.gain.cancelScheduledValues(time);
  g.gain.setValueAtTime(0, time);
  g.gain.linearRampToValueAtTime(peakAmp, time + a);

  // For synths with S=1.0, decay does nothing (stays at peak)
  // For S<1.0, ramps down to sustain level
  g.gain.linearRampToValueAtTime(peakAmp * s, time + a + d);

  // Release function: smooth exponential decay
  return (endTime) => {
    try {
      g.gain.cancelAndHoldAtTime(endTime);
      const timeConstant = Math.max(r * 0.3, 0.005);
      g.gain.setTargetAtTime(0, endTime, timeConstant);
    } catch(_) {
      // Fallback: calculate sustain value manually
      try {
        g.gain.cancelScheduledValues(endTime);
        g.gain.setValueAtTime(peakAmp * s, endTime);
        const timeConstant = Math.max(r * 0.3, 0.005);
        g.gain.setTargetAtTime(0, endTime, timeConstant);
      } catch(__) {}
    }
  };
}

// Sample ADSR: H22 approach for natural sample playback
// Handles long decay times, cancels automation before release
function applySampleADSR(g, time, a, d, s, r, peakAmp=1){
  g.gain.cancelScheduledValues(time);
  g.gain.setValueAtTime(0, time);
  g.gain.linearRampToValueAtTime(peakAmp, time + a);
  g.gain.linearRampToValueAtTime(peakAmp * s, time + a + d);

  // H22: Release function cancels decay automation before starting
  return (endTime)=>{
    try {
      // Cancel any ongoing automation (e.g., long decay ramp)
      g.gain.cancelScheduledValues(endTime);
      // Set current value at release start time
      g.gain.setValueAtTime(g.gain.value, endTime);
      // Ramp to silence over release time
      g.gain.exponentialRampToValueAtTime(0.0001, endTime + r);
    } catch(_) {}
  };
}

function makeNoisyIR(ac, durSec=1.8, decay=0.9995){
  const sr = ac.sampleRate, len = (sr*durSec)|0, chs = 2;
  const buf = ac.createBuffer(chs, len, sr);
  for(let c=0;c<chs;c++){
    const d = buf.getChannelData(c);
    let amp = 1.0;
    for(let i=0;i<len;i++){ const w = (Math.random()*2-1); amp *= decay; d[i] = w * amp; }
  }
  return buf;
}
function makeTanhCurve(amount=0.35){
  const n=2048, c=new Float32Array(n);
  const k = Math.max(0.0001, amount*3.0);
  for(let i=0;i<n;i++){ const x = (i/(n-1))*2-1; c[i] = Math.tanh(k*x)/Math.tanh(k); }
  return c;
}

/* ===== Sound Generators (samples first, synth fallback) ===== */
function playVoice(index, time, pitch=1.0, amp=1.0, morphTo=null, morphFactor=0){
  if (morphFactor > 0 && morphTo !== null && morphTo !== index){
    const base = 1 - morphFactor;
    _play(index, time, pitch, amp * base);
    _play(morphTo, time, pitch, amp * morphFactor);
  } else {
    _play(index, time, pitch, amp);
  }
}

function _play(i, time, pitch=1, amp=1){
  const A=adsr[i].a, D=adsr[i].d, S=adsr[i].s, R=adsr[i].r;
  const g = audioCtx.createGain();

  // route through per-track mixer path (Trim -> Tone -> Split -> dry/sends)
  g.connect(trackIn[i]);

  let end = time + 0.5;

  
if (sampleBufs[i]) {
  const src = audioCtx.createBufferSource();
  src.buffer = sampleBufs[i];
  src.playbackRate.value = pitch;
  const dur = Math.max(0.02, src.buffer.duration);
  const cap = (TRACK_CAP_SEC && TRACK_CAP_SEC[i] != null ? TRACK_CAP_SEC[i] : 6);
  const natural = dur / Math.max(0.001, pitch);
  const tail = Math.max(0.06, Math.min(0.25, R + 0.06));
  const end = time + Math.min(natural + tail, cap + tail);
  const rel = applySampleADSR(g, time, A, D, S, R, amp);
  if (natural > cap) {
    try {
      g.gain.setValueAtTime(g.gain.value, end - 0.12);
      g.gain.linearRampToValueAtTime(0.0, end - 0.02);
    } catch(_) {}
  }
  src.connect(g); src.start(time); src.stop(end);
  if (natural <= cap) rel(end);
  return;
}


  switch(i){
    case 0:{ 
      // Kik — 808-style Long↓ Sub (refined: de-click gate, cleaner headroom)
      const o = audioCtx.createOscillator(); 
      o.type = 'sine';
      const base = 45 * pitch;
      const startF = base * 2.1; // quick downward pitch sweep
      o.frequency.setValueAtTime(startF, time);
      o.frequency.exponentialRampToValueAtTime(base, time + 0.10);

      // D15: Gate BEFORE filters with longer fade for pitch-sweep transient
      const gate = audioCtx.createGain();
      gate.gain.setValueAtTime(0.00001, time);
      gate.gain.exponentialRampToValueAtTime(1, time + 0.010); // 10ms for smooth sweep onset

      // Minimal tone: tiny soft drive + DC safety
      const sh = audioCtx.createWaveShaper(); sh.curve = makeTanhCurve(0.20); sh.oversample = '4x';
      const hp = audioCtx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 18;

      // End schedule (fixed 1.2s for synth)
      const end = time + 1.20;

      // D15: Enforce minimum Attack/Release to work with gate (prevents pops)
      const safeA = Math.max(A, 0.012); // Minimum 12ms attack (longer than 10ms gate fade)
      const safeR = Math.max(R, 0.050); // Minimum 50ms release for smooth fadeout

      // Synth ADSR: simplified envelope with safe minimums
      const rel = applySynthADSR(g, time, safeA, D, S, safeR, amp * 1.0);

      // D15: Gate before shaper/filter for clean start/end
      o.connect(gate).connect(sh).connect(hp).connect(g);
      // D15: Oscillator stops well after release completes (5x time constant)
      const stopTime = end + safeR * 5 + 0.1;
      o.start(time); o.stop(stopTime);
      rel(end);
      break; }
    case 1:{ 
      // Dusk — mellow EP (refined: brighter LP, de-click gate, gentle tilt)
      const base = 130.8128 * pitch; // C3 * pitch factor
      const o1 = audioCtx.createOscillator(); o1.type='sine'; o1.frequency.value = base;
      const o2 = audioCtx.createOscillator(); o2.type='sine'; o2.frequency.value = base * 2.03; // short “tine” overtone

      // D15: Gate BEFORE filters to prevent filter transients
      const gate = audioCtx.createGain();
      gate.gain.setValueAtTime(0.00001, time);
      gate.gain.exponentialRampToValueAtTime(1, time + 0.008); // 8ms gentle fade

      // Tone shaping (slightly brighter than before to un-muffle FX)
      const tilt = audioCtx.createBiquadFilter(); tilt.type='peaking'; tilt.frequency.value = 1200; tilt.Q.value = 0.7; tilt.gain.value = -0.6;
      const lp   = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 3000; lp.Q.value = 0.8;
      const sh   = audioCtx.createWaveShaper(); sh.curve = makeTanhCurve(0.15); sh.oversample = '4x';
      const hp   = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 22;

      // Short blip envelope for the tine partial
      const tine = audioCtx.createGain(); tine.gain.value = 0;
      const now = time;
      tine.gain.setValueAtTime(0, now);
      tine.gain.linearRampToValueAtTime(0.28 * amp, now + 0.006);
      tine.gain.exponentialRampToValueAtTime(0.0008, now + 0.05);

      // D15: Enforce minimum Attack/Release to work with gate
      const safeA = Math.max(A, 0.010); // Minimum 10ms attack (longer than 8ms gate fade)
      const safeR = Math.max(R, 0.050); // Minimum 50ms release

      // ADSR on track VCA; sustain/rel controlled by panel
      const end = time + 1.20; // Fixed 1.2s for synth (was 3.10)
      const rel = applySynthADSR(g, time, safeA, D, S, safeR, amp * 0.9);

      // D15: Gate before filters, both oscillators merge at gate
      o1.connect(gate);
      o2.connect(tine).connect(gate);
      gate.connect(tilt).connect(lp).connect(sh).connect(hp).connect(g);

      // D15: Oscillator stops well after release completes (5x time constant)
      const stopTime = end + safeR * 5 + 0.1;
      o1.start(time); o2.start(time);
      o1.stop(stopTime); o2.stop(stopTime);
      rel(end);
      break; }
    case 2:{ 
      // Open — clean noise hat with HPF+BP, pop-safe gates
      // Reuse/create a shared noise buffer once (no per-hit allocations)
      let buf = window.__hatNoiseBuffer;
      if (!buf){
        const n = Math.floor(audioCtx.sampleRate * 0.4);
        buf = audioCtx.createBuffer(1, n, audioCtx.sampleRate);
        const ch = buf.getChannelData(0);
        for (let j=0;j<n;j++) ch[j] = (Math.random()*2 - 1);
        window.__hatNoiseBuffer = buf;
      }
      const src = audioCtx.createBufferSource(); src.buffer = buf;

      const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 5500 * pitch;
      const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 8000 * pitch; bp.Q.value = 0.7;

      // Local amp env + gate (avoid clicks)
      const v = audioCtx.createGain(); v.gain.value = 0;
      const gate = audioCtx.createGain(); gate.gain.value = 0;
      gate.gain.setValueAtTime(0, time);
      gate.gain.linearRampToValueAtTime(1, time + 0.001);
      const end = time + 0.26;
      // Gate stays at 1, ADSR release handles fadeout

      // Track ADSR still applies via g
      const rel = applySynthADSR(g, time, A, D, S, R, amp * 0.9);

      v.gain.setValueAtTime(0, time);
      v.gain.linearRampToValueAtTime(1, time + 0.001);
      v.gain.exponentialRampToValueAtTime(0.0008, time + 0.22);

      src.connect(hp).connect(bp).connect(v).connect(gate).connect(g);
      // Cap synth duration at 2 seconds max
      const stopTime = Math.min(end + R * 2 + 0.05, time + 2.0);
      src.start(time); src.stop(stopTime);
      rel(end);
      break; }
    case 3:{ 
      // Base — Deep mono sub (Mono Base): pure sine body, minimal color, de-clicked
      const f = 34 * pitch; // ~C1 region when pitch ~1
      const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.value = f;

      // Add a tiny second harmonic for presence
      const o2 = audioCtx.createOscillator(); o2.type='sine'; o2.frequency.value = f * 2.0;
      const o2v = audioCtx.createGain(); o2v.gain.value = 0;
      o2v.gain.setValueAtTime(0, time);
      o2v.gain.linearRampToValueAtTime(0.08 * amp, time + 0.006);
      o2v.gain.exponentialRampToValueAtTime(0.0008, time + 0.10);

      // Soft drive and DC safety (very gentle)
      const sh = audioCtx.createWaveShaper(); sh.curve = makeTanhCurve(0.18); sh.oversample = '4x';
      const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 20;

      // De-click gate before track VCA
      const gate = audioCtx.createGain(); gate.gain.value = 0;
      gate.gain.setValueAtTime(0, time);
      gate.gain.linearRampToValueAtTime(1, time + 0.002);
      const end = time + 1.20; // Fixed 1.2s for synth (was 1.60)
      // Gate stays at 1, ADSR release handles fadeout

      // Track ADSR
      const rel = applySynthADSR(g, time, A, D, S, R, amp * 1.0);

      o.connect(sh).connect(hp).connect(gate).connect(g);
      o2.connect(o2v).connect(sh);

      // Cap synth duration at 2 seconds max
      const stopTime = Math.min(end + R * 2 + 0.05, time + 2.0);
      o.start(time); o2.start(time);
      o.stop(stopTime); o2.stop(stopTime);
      rel(end);
      break; }
    case 4:{
      // Bloom — Tape Ensemble (pad): fixed micro-delays, darker tilt, pop-safe
      // Reuse a custom periodic wave (mostly sine with gentle evens)
      let wave = window.__bloomWave;
      if (!wave){
        const re = new Float32Array(32), im = new Float32Array(32);
        re[1]=1.0; re[2]=0.25; re[4]=0.12; re[6]=0.06;
        wave = audioCtx.createPeriodicWave(re, im, { disableNormalization: false });
        window.__bloomWave = wave;
      }
      const o = audioCtx.createOscillator(); o.setPeriodicWave(wave);
      // Base C4 scaled by pitch knob; musical bloom works across wide range
      o.frequency.value = 261.63 * pitch;

      // D14: De-click gate BEFORE filters to prevent filter transients
      const gate = audioCtx.createGain();
      gate.gain.setValueAtTime(0.00001, time);
      gate.gain.exponentialRampToValueAtTime(1, time + 0.020); // 20ms gentle curve

      // Tone: gentle tilt + LP to avoid harshness into FX
      const tilt = audioCtx.createBiquadFilter(); tilt.type='peaking'; tilt.frequency.value = 1200; tilt.Q.value=0.7; tilt.gain.value = -1.5;
      const lp   = audioCtx.createBiquadFilter(); lp.type='lowpass';  lp.frequency.value = 2500; lp.Q.value = 0.8;

      // Fixed ensemble delays (no modulation)
      const pre  = audioCtx.createGain(); pre.gain.value = 0.95;
      const d1   = audioCtx.createDelay(); d1.delayTime.value = 0.006;
      const d2   = audioCtx.createDelay(); d2.delayTime.value = 0.010;
      const sum  = audioCtx.createGain(); sum.gain.value = 0.8;

      // End timing: allow a long natural hold; per-track ADSR still shapes final amp
      const end = time + 1.20; // Fixed 1.2s for synth (was 3.20)
      // Gate stays at 1, ADSR release handles fadeout

      // Track ADSR on the global g (panel-controlled)
      const rel = applySynthADSR(g, time, A, D, S, R, amp * 0.92);

      // D14: Gate before filters, osc starts immediately
      o.connect(gate).connect(tilt).connect(lp).connect(pre);
      pre.connect(d1); pre.connect(d2); d1.connect(sum); d2.connect(sum);
      sum.connect(g);

      // Cap synth duration at 2 seconds max
      const stopTime = Math.min(end + R * 2 + 0.05, time + 2.0);
      o.start(time); o.stop(stopTime);
      rel(end);
      break; }
    case 5:{
      // Ritual — Tight: sine thump + tiny overtone blip; pop-safe, DC-safe
      const hz = 110 * pitch; // A2 region scaled by pitch
      const base = audioCtx.createOscillator(); base.type = 'sine'; base.frequency.value = hz;
      const over = audioCtx.createOscillator(); over.type = 'sine'; over.frequency.value = hz * 2.5;

      // Overtone blip envelope
      const oV = audioCtx.createGain(); oV.gain.value = 0;
      oV.gain.setValueAtTime(0, time);
      oV.gain.linearRampToValueAtTime(0.25 * amp, time + 0.004);
      oV.gain.exponentialRampToValueAtTime(0.0008, time + 0.06);

      // Mild tone shaping + DC safety
      const tilt = audioCtx.createBiquadFilter(); tilt.type='peaking'; tilt.frequency.value=1200; tilt.Q.value=0.7; tilt.gain.value = 0.0;
      const hp   = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 28;

      // De-click safety gate
      const gate = audioCtx.createGain(); gate.gain.value = 0;
      gate.gain.setValueAtTime(0, time);
      gate.gain.linearRampToValueAtTime(1, time + 0.002);

      // Track ADSR
      const end = time + 0.90; // Keep short for Ritual character
      // Gate stays at 1, ADSR release handles fadeout
      const rel = applySynthADSR(g, time, A, D, S, R, amp * 1.0);

      base.connect(tilt).connect(hp).connect(gate).connect(g);
      over.connect(oV).connect(tilt);

      // Cap synth duration at 2 seconds max
      const stopTime = Math.min(end + R * 2 + 0.05, time + 2.0);
      base.start(time); over.start(time);
      base.stop(stopTime); over.stop(stopTime);
      rel(end);
      break; }
    case 6:{
      // Poli — soft skin pluck (deeper/louder), pop-safe
      // Sine with quick settle; short musical tail; minimal tone shaping
      const f0 = (120 + Math.random()*40) * pitch;
      const o  = audioCtx.createOscillator(); o.type='sine';
      o.frequency.setValueAtTime(f0*1.2, time);
      o.frequency.exponentialRampToValueAtTime(f0, time + 0.08);

      // Local VCA and de-click gate
      const v = audioCtx.createGain(); v.gain.value = 0;
      v.gain.setValueAtTime(0, time);
      v.gain.linearRampToValueAtTime(1, time + 0.005);
      v.gain.exponentialRampToValueAtTime(0.0008, time + 0.30);

      const gate = audioCtx.createGain(); gate.gain.value = 0;
      gate.gain.setValueAtTime(0, time);
      gate.gain.linearRampToValueAtTime(1, time + 0.0015);

      // Gentle tilt / HPF for cleanliness
      const tilt = audioCtx.createBiquadFilter(); tilt.type='peaking'; tilt.frequency.value = 1200; tilt.Q.value=0.7; tilt.gain.value = -0.4;
      const hp   = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 18;

      // Track ADSR still applies
      const rel = applySynthADSR(g, time, A, D, S, R, amp * 1.15);

      const end = time + 0.34;
      // Gate stays at 1, ADSR release handles fadeout

      // Cap synth duration at 2 seconds max
      const stopTime = Math.min(end + R * 2 + 0.05, time + 2.0);
      o.connect(v).connect(tilt).connect(hp).connect(gate).connect(g);
      o.start(time); o.stop(stopTime);
      rel(end);
      break; }
    case 7:{
      // Prog — Swarm Harp (Low Formant): detuned triangle cluster, plucked, pop-safe
      const partials = 6;
      const det = 9; // cents spread width
      const hz = 261.63 * pitch; // C4 base * pitch
      
      // D15: Gate BEFORE filter to prevent filter transients at start/end
      const gate = audioCtx.createGain();
      gate.gain.setValueAtTime(0.0001, time);
      gate.gain.exponentialRampToValueAtTime(1, time + 0.008);

      // Tone tilt (low-formant emphasis) after gate
      const tilt = audioCtx.createBiquadFilter(); tilt.type='peaking';
      tilt.frequency.value = 1200; tilt.Q.value = 1.1; tilt.gain.value = -2.1;

      // Local sum
      const sum = audioCtx.createGain(); sum.gain.value = 0.85;

      // Envelope params (per partial) and overall end timing
      const atk = 0.003, dec = 0.09, sus = 0.55, rel = 0.70;
      const tail = 2.6;
      // D15: Oscillators must stop AFTER envelopes finish fading to prevent pop
      const envelopeEnd = time + tail + rel;
      const stopTime = envelopeEnd + 0.05; // Stop 50ms after envelope completes

      // Per-track ADSR still shapes final amp
      const relFn = applySynthADSR(g, time, A, D, S, R, amp * 0.95);

      for (let i = 0; i < partials; i++){
        const o = audioCtx.createOscillator(); o.type='triangle';
        const cents = (i - (partials - 1) / 2) * (det / partials);
        o.frequency.value = hz * Math.pow(2, cents / 1200);

        const v = audioCtx.createGain(); v.gain.value = 0;
        // D15: Exponential release to true silence prevents end pop
        v.gain.setValueAtTime(0, time);
        v.gain.linearRampToValueAtTime(1, time + atk);
        v.gain.linearRampToValueAtTime(sus, time + atk + dec);
        v.gain.setValueAtTime(sus, time + tail);
        v.gain.exponentialRampToValueAtTime(0.0001, envelopeEnd);

        o.connect(v).connect(sum);
        o.start(time); o.stop(stopTime);
      }

      // D15: Gate before filter for clean start/end
      sum.connect(gate).connect(tilt).connect(g);
      relFn(time + tail + rel);
      break; }
  }
}

/* ===== MORPH ENGINE ===== */
/* In this version, only crossfade morphing is used. */
function morphCrossfade(iA, iB, t, pitchA, amt){
  // iA: source track index
  // iB: target track index (ignored here; reserved for future per-step routing)
  // t:  scheduled time
  // pitchA: playback rate for the source
  // amt: morph depth 0..1 (ignored in this simplified engine; voice synth handles wet mix)
  playVoice(iA, t, pitchA, 1.0, iB, amt);
}

/* ===== Reverse Ghost scheduling using tap pool ===== */
function scheduleGhostCluster(ch, hitTime){
  const sendAmt = ghostSendGains[ch].gain.value;
  if (sendAmt <= 0) return;

  // H20: Logarithmic frequency mapping (top to bottom, musically spaced)
  const baseHz = ({0:80, 1:160, 2:320, 3:640, 4:1250, 5:2500, 6:5000, 7:7500, 8:10000})[ch] || 1000;
  const center = baseHz * semisToRatio(ghostPitchSemis);

  const dens = (typeof arguments[2]==='number' ? arguments[2] : ghostDensity);

  // C16: BPM-aware density with granular range (1/2 → 1/128 note)
  const beatSec = 60 / tempo;
  const divisions = [
    beatSec * 2.0,    // 1/2 note
    beatSec * 1.0,    // 1/4 note
    beatSec * 0.5,    // 1/8 note
    beatSec * 0.25,   // 1/16 note
    beatSec * 0.125,  // 1/32 note
    beatSec * 0.0625, // 1/64 note (granular)
    beatSec * 0.03125 // 1/128 note (dense granular)
  ];
  const divIdx = Math.floor(dens * (divisions.length - 1));
  const spacing = divisions[Math.min(divIdx, divisions.length - 1)];

  const n = Math.min(8, Math.max(1, Math.round(dens * 7) + 1));  // H20: 1-8 taps (was 1-6)
  const firstDelay = 0.12;

  for (let i=0; i<n; i++){
    const delaySec = firstDelay + i*spacing;
    const ampScale = Math.pow(0.85, i);
    scheduleGhostTapFromPool(hitTime, delaySec, center, ampScale, i);  // H20: Pass tap index
  }
}
function scheduleGhostTapFromPool(hitTime, delaySec, centerHz, ampScale, tapIndex){
  const tap = ghostTaps[ghostTapIdx++ % GHOST_TAPS];

  // H20: Oblique controls randomness (0=deterministic, 1=random)
  const useRandom = Math.random() < ghostOblique;

  // H21: Timing variation - random drift AND spacing variation when Oblique engaged
  const timingDrift = useRandom ? (Math.random() * 2 - 1) * 0.1 : 0; // ±100ms if random
  const spacingVar = useRandom ? (0.7 + Math.random() * 0.6) : 1.0; // 70%-130% spacing variation
  const variedDelay = delaySec * spacingVar;

  const s = Math.max(audioCtx.currentTime + 0.01, hitTime + variedDelay + timingDrift);

  // H21: Length variation when Oblique engaged
  const lengthVar = useRandom ? (0.5 + Math.random() * 1.0) : 1.0; // 50%-150% length variation
  const variedLength = ghostLen * lengthVar;
  const e = s + Math.max(0.06, variedLength);

  tap.d.delayTime.setValueAtTime(variedDelay, s - 0.01);
  tap.bp.frequency.setValueAtTime(centerHz, s - 0.01);
  tap.ap.frequency.setValueAtTime(centerHz*0.7, s - 0.01);
  tap.mix.gain.setValueAtTime(ghostBoost * ampScale, s - 0.01);

  tap.tap.gain.cancelScheduledValues(s - 0.02);

  // H20: Reverse pattern - deterministic or random based on Oblique
  let isReverse;
  if (useRandom) {
    // Random mode: probability-based
    isReverse = Math.random() < ghostReverse;
  } else {
    // Deterministic mode: pattern-based
    // ghostReverse=0.0 → all forward (never reverse)
    // ghostReverse=1.0 → all reverse (always reverse)
    // ghostReverse=0.5 → alternating (F,R,F,R...)
    // ghostReverse=0.25 → pattern (F,F,F,R,F,F,F,R...)
    const idx = tapIndex || 0;
    const reverseThreshold = ghostReverse;
    // Use tap index to create repeating pattern
    const patternPosition = idx % 8; // 8-tap pattern repeats
    isReverse = (patternPosition / 8) < reverseThreshold;
  }

  if (isReverse){
    tap.tap.gain.setValueAtTime(0.0001, s);
    tap.tap.gain.linearRampToValueAtTime(1.0, e - 0.02);
    tap.tap.gain.exponentialRampToValueAtTime(0.0001, e);
  } else {
    tap.tap.gain.setValueAtTime(1.0, s);
    tap.tap.gain.exponentialRampToValueAtTime(0.0001, e);
  }
}



/* ===== Tempo wiring (CR-022) ===== */
(function(){
  const el = document.getElementById('tempo');
  if (!el) return;
  const disp = document.getElementById('tempoVal');
  // Initialize tempo from slider on load
  const v0 = Math.max(+el.min||40, Math.min(+el.max||240, +el.value||120));
  tempo = v0;
  if (disp) disp.textContent = String(Math.round(v0));
  el.addEventListener('input', (e)=>{
    const v = Math.max(+el.min||40, Math.min(+el.max||240, +e.target.value||tempo));
    tempo = v;
    if (disp) disp.textContent = String(Math.round(v));
    // If transport is running, gently realign the scheduler so changes take effect immediately
    try {
      if (isPlaying && audioCtx && typeof audioCtx.currentTime === 'number') {
        nextNoteTime = audioCtx.currentTime + 0.03; // small pad
      }
    } catch(_) {}
  });
})();

/* ===== Harmonic Framework UI Wiring ===== */
(function(){
  const rootEl = document.getElementById('globalRoot');
  const scaleEl = document.getElementById('globalScale');

  if (rootEl) {
    rootEl.addEventListener('change', (e) => {
      globalRoot = parseInt(e.target.value, 10);
      // Rebuild Harmonic Gate resonator bank with new key
      if (typeof rebuildHarmonicGate === 'function') {
        rebuildHarmonicGate();
      }
      // G13: Rebuild diatonic pitch dropdowns when root changes
      for (let trackIdx = 0; trackIdx < NUM_SOUNDS; trackIdx++) {
        if (diatonicEnabled[trackIdx]) {
          rebuildPitchDropdownsForTrack(trackIdx);
        }
      }
    });
  }

  if (scaleEl) {
    scaleEl.addEventListener('change', (e) => {
      globalScale = e.target.value;
      // Rebuild Harmonic Gate resonator bank with new scale
      if (typeof rebuildHarmonicGate === 'function') {
        rebuildHarmonicGate();
      }
      // G13: Rebuild diatonic pitch dropdowns when scale changes
      for (let trackIdx = 0; trackIdx < NUM_SOUNDS; trackIdx++) {
        if (diatonicEnabled[trackIdx]) {
          rebuildPitchDropdownsForTrack(trackIdx);
        }
      }
    });
  }
})();

/* ===== HUM FX — Algorithmic Reverb State ===== */
var hum = {
  baseHz: 220,
  color: 0.0,  // renamed to "Warmth" in UI
  tailSec: 12.0,
  wet: 1.0
};
(function(){
  const get = id => document.getElementById(id);
  const b = get('humBase'), c = get('humColor'), tl = get('humTail'), w = get('humWet');
  if (!b || !c || !tl || !w) return;

  b.addEventListener('input', e=> {
    hum.baseHz = +e.target.value;
    applyHumParams();
  });

  c.addEventListener('input', e=> {
    hum.color = +e.target.value;
    applyHumParams();
  });

  tl.addEventListener('input', e=> {
    hum.tailSec = +e.target.value;
    applyHumParams(); // smooth tail update via setTargetAtTime
  });

  w.addEventListener('input', e=> {
    hum.wet = +e.target.value;
    setHumWet(+e.target.value);
  });

  // Initialize wet gain
  try{ setHumWet(+w.value||0); }catch(_){}
})();


/* Note: HUM UI bindings handled above - this section is now redundant but kept for compatibility */

/* ===== Phrase Sampler Infrastructure (A01) ===== */
// Phrase storage: array of AudioBuffers, one per recorded phrase
let phraseLibrary = []; // Each entry: {buffer: AudioBuffer, name: string}
let phraseAssignments = Array(MAX_STEPS).fill(null); // Which phrase plays on each step (null = silence)
let phraseShufflePatterns = Array(MAX_STEPS).fill(null); // Shuffle pattern per slot: null = original, {pattern: array, mode: 'remix'|'chaos', reverse: array}
let phraseShuffledBuffers = Array(MAX_STEPS).fill(null); // Cached shuffled audio buffers
let phraseActiveMode = Array(MAX_STEPS).fill(null); // Active mode per slot: null = no shuffle, 'remix' or 'chaos'

// Recording state
let phraseRecording = false;
let phraseRecordStartBeat = -1;
let phraseRecBuffersL = [];
let phraseRecBuffersR = [];
let phraseRecLength = 0;
let phraseRecSampleRate = 0;
let phraseRecTempo = 120; // Capture tempo at recording start
let phraseRecStartTime = 0; // A06: Exact audio context time when recording started
let phraseRecActualStartTime = 0; // A07: Actual audioCtx.currentTime when recording began
let phraseRecExpectedDuration = 0; // A06: Exact duration in seconds for 64 beats
let phraseRecTargetSamples = 0; // C13: Total samples to record (includes offset compensation)

// Phrase recorder setup (tap master bus)
let phraseRecNode = null;
let phraseScriptProc = null;
let phraseRecorderMode = null;

async function initPhraseRecorder(){
  phraseRecSampleRate = audioCtx.sampleRate;

  // Try AudioWorklet first (preferred for performance)
  if (typeof AudioWorkletNode !== 'undefined' && !phraseScriptProc){
    try{
      await audioCtx.audioWorklet.addModule('data:text/javascript,' + encodeURIComponent(`
        class PhraseRecorder extends AudioWorkletProcessor {
          constructor() { super(); this.recording = false; this.port.onmessage = e => { this.recording = e.data === 'record'; }; }
          process(inputs, outputs, parameters) {
            if (this.recording && inputs[0] && inputs[0][0]) {
              const L = inputs[0][0], R = inputs[0][1] || L;
              this.port.postMessage({L: L.slice(), R: R.slice()});
            }
            return true;
          }
        }
        registerProcessor('phrase-recorder', PhraseRecorder);
      `));
      phraseRecNode = new AudioWorkletNode(audioCtx, 'phrase-recorder', {numberOfInputs:1, numberOfOutputs:0});
      const tapGain = audioCtx.createGain(); tapGain.gain.value = 1.0;
      outGain.connect(tapGain).connect(phraseRecNode);
      phraseRecNode.port.onmessage = (e)=>{
        if (!phraseRecording) return;
        const {L,R}=e.data;
        phraseRecBuffersL.push(new Float32Array(L));
        phraseRecBuffersR.push(new Float32Array(R));
        phraseRecLength += L.length;
      };
      phraseRecorderMode = 'worklet';
      return;
    }catch(err){
      console.warn('Phrase worklet recorder unavailable; falling back:', err);
    }
  }

  // Fallback ScriptProcessor
  phraseScriptProc = audioCtx.createScriptProcessor(4096, 2, 2);
  const tapGain = audioCtx.createGain(); tapGain.gain.value = 1.0;
  outGain.connect(tapGain).connect(phraseScriptProc);
  phraseScriptProc.onaudioprocess = (e)=>{
    if (!phraseRecording) return;
    const inL = e.inputBuffer.getChannelData(0);
    const inR = e.inputBuffer.numberOfChannels>1 ? e.inputBuffer.getChannelData(1) : inL;
    phraseRecBuffersL.push(new Float32Array(inL));
    phraseRecBuffersR.push(new Float32Array(inR));
    phraseRecLength += inL.length;
  };
  const nullOut = audioCtx.createGain(); nullOut.gain.value = 0.0;
  phraseScriptProc.connect(nullOut); nullOut.connect(audioCtx.destination);
  phraseRecorderMode = 'script';
}

function startPhraseRecording(scheduledStartTime){
  phraseRecBuffersL=[]; phraseRecBuffersR=[]; phraseRecLength=0; phraseRecSampleRate=audioCtx.sampleRate;
  phraseRecTempo = tempo; // Capture current tempo for exact duration calculation

  // A06: Store exact scheduled start time and calculate expected duration
  phraseRecStartTime = scheduledStartTime;
  phraseRecActualStartTime = audioCtx.currentTime; // A07: Capture when recording actually starts
  const secondsPerBeat = 60 / phraseRecTempo;
  const secondsPerStep = secondsPerBeat / 4; // 16th notes
  phraseRecExpectedDuration = secondsPerStep * 64; // Exactly 64 steps

  // C13: Calculate total samples to record (phrase duration + lookahead offset)
  const offsetSeconds = phraseRecStartTime - phraseRecActualStartTime;
  const offsetSamples = Math.max(0, Math.round(offsetSeconds * phraseRecSampleRate));
  const exactSampleCount = Math.round(phraseRecExpectedDuration * phraseRecSampleRate);
  phraseRecTargetSamples = exactSampleCount + offsetSamples;

  phraseRecording=true;
  if (phraseRecorderMode === 'worklet' && phraseRecNode){ phraseRecNode.port.postMessage('record'); }
}

function stopPhraseRecording(){
  phraseRecording=false;
  if (phraseRecorderMode === 'worklet' && phraseRecNode){ phraseRecNode.port.postMessage('stop'); }

  // A07: Calculate offset - recording started before the scheduled beat
  const offsetSeconds = phraseRecStartTime - phraseRecActualStartTime;
  const offsetSamples = Math.round(offsetSeconds * phraseRecSampleRate);
  const exactSampleCount = Math.round(phraseRecExpectedDuration * phraseRecSampleRate);

  // Merge buffers into AudioBuffer
  const totalLength = phraseRecLength;
  if (totalLength === 0) return null;

  const mergedL = new Float32Array(totalLength);
  const mergedR = new Float32Array(totalLength);
  let offset = 0;
  for (let i=0; i<phraseRecBuffersL.length; i++){
    mergedL.set(phraseRecBuffersL[i], offset);
    mergedR.set(phraseRecBuffersR[i], offset);
    offset += phraseRecBuffersL[i].length;
  }

  // A07: Extract exact phrase samples, starting from the offset position
  const finalLength = exactSampleCount;
  const buffer = audioCtx.createBuffer(2, finalLength, phraseRecSampleRate);
  const bufL = buffer.getChannelData(0);
  const bufR = buffer.getChannelData(1);

  // Copy samples from the offset position (skipping lookahead buffer)
  for (let i = 0; i < finalLength; i++) {
    const srcIdx = offsetSamples + i;
    bufL[i] = srcIdx < totalLength ? mergedL[srcIdx] : 0;
    bufR[i] = srcIdx < totalLength ? mergedR[srcIdx] : 0;
  }

  // A11 Redux: Add minimal loop crossfade to prevent pop at loop point
  // 5ms fade-out at end, 5ms fade-in at start for seamless looping
  const fadeSamples = Math.floor(0.005 * phraseRecSampleRate); // 5ms
  const fadeEnd = Math.min(fadeSamples, finalLength);

  // Fade-in at start
  for (let i = 0; i < fadeEnd; i++) {
    const gain = i / fadeSamples;
    bufL[i] *= gain;
    bufR[i] *= gain;
  }

  // Fade-out at end
  for (let i = 0; i < fadeEnd; i++) {
    const sampleIdx = finalLength - fadeEnd + i;
    const gain = 1.0 - (i / fadeSamples);
    bufL[sampleIdx] *= gain;
    bufR[sampleIdx] *= gain;
  }

  return buffer;
}

// Play a phrase at the given time
// Fisher-Yates shuffle algorithm
function shuffleArray(array) {
  const arr = [...array]; // Create copy
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// Create shuffled phrase buffer by rearranging slices with crossfade envelopes
function createShuffledPhrase(originalBuffer, shuffleData) {
  const mode = shuffleData.mode || 'remix';
  const numSlices = mode === 'chaos' ? 32 : 16; // Chaos = 2 beats per slice, Remix = 4 beats per slice
  const shufflePattern = shuffleData.pattern;
  const reverseFlags = shuffleData.reverse || [];

  const numChannels = originalBuffer.numberOfChannels;
  const sampleRate = originalBuffer.sampleRate;
  const totalLength = originalBuffer.length;
  const sliceLength = Math.floor(totalLength / numSlices);

  // Crossfade duration in samples (10ms to prevent pops)
  const crossfadeSamples = Math.floor(sampleRate * 0.01);

  // Create new buffer same length as original
  const shuffledBuffer = audioCtx.createBuffer(numChannels, totalLength, sampleRate);

  // Process each channel
  for (let ch = 0; ch < numChannels; ch++) {
    const originalData = originalBuffer.getChannelData(ch);
    const shuffledData = shuffledBuffer.getChannelData(ch);

    // Copy slices in shuffled order
    for (let i = 0; i < numSlices; i++) {
      const sourceSliceIdx = shufflePattern[i];
      const shouldReverse = reverseFlags[i] || false;
      const sourceStart = sourceSliceIdx * sliceLength;
      const destStart = i * sliceLength;
      const actualSliceLength = Math.min(sliceLength, totalLength - destStart);

      // Copy slice data (forward or reverse)
      for (let s = 0; s < actualSliceLength; s++) {
        const sourceOffset = shouldReverse ? (actualSliceLength - 1 - s) : s;
        let sample = originalData[sourceStart + sourceOffset];

        // Apply fade-in at start of slice
        if (s < crossfadeSamples) {
          const fadeIn = s / crossfadeSamples;
          sample *= fadeIn;
        }

        // Apply fade-out at end of slice
        if (s >= actualSliceLength - crossfadeSamples) {
          const fadeOut = (actualSliceLength - s) / crossfadeSamples;
          sample *= fadeOut;
        }

        shuffledData[destStart + s] = sample;
      }
    }
  }

  return shuffledBuffer;
}

function schedulePhrase(phraseIdx, atTime, slotIdx = null){
  if (phraseIdx == null || phraseIdx < 0 || phraseIdx >= phraseLibrary.length) return;
  const phrase = phraseLibrary[phraseIdx];
  if (!phrase || !phrase.buffer) return;

  const src = audioCtx.createBufferSource();

  // Check if this slot has a shuffle pattern
  if (slotIdx != null && phraseShufflePatterns[slotIdx] != null) {
    // Use cached shuffled buffer if available, otherwise create it
    if (phraseShuffledBuffers[slotIdx] == null) {
      phraseShuffledBuffers[slotIdx] = createShuffledPhrase(phrase.buffer, phraseShufflePatterns[slotIdx]);
    }
    src.buffer = phraseShuffledBuffers[slotIdx];
  } else {
    src.buffer = phrase.buffer;
  }

  src.playbackRate.value = pitches[PHRASES_IDX]; // C15: Enable pitch control
  src.connect(trackIn[PHRASES_IDX]); // C14: Route through track mixer for volume control
  src.start(atTime);
}

// Update all phrase dropdowns after recording a new phrase
function updatePhraseDropdowns() {
  const phraseSelects = document.querySelectorAll('.phraseSelect');
  phraseSelects.forEach(select => {
    const currentValue = select.value;
    const step = parseInt(select.dataset.step);

    // Rebuild options
    select.innerHTML = '';

    const noneOpt = document.createElement('option');
    noneOpt.value = '';
    noneOpt.textContent = '—';
    select.appendChild(noneOpt);

    for (let i = 0; i < phraseLibrary.length; i++) {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = phraseLibrary[i].name || `Phrase ${i + 1}`;
      select.appendChild(opt);
    }

    // Restore selection if still valid
    if (currentValue !== '' && parseInt(currentValue) < phraseLibrary.length) {
      select.value = currentValue;
    }
  });

  // Update phrase info display
  const phraseInfo = document.getElementById('phraseInfo');
  if (phraseInfo) {
    phraseInfo.textContent = `${phraseLibrary.length} phrase${phraseLibrary.length !== 1 ? 's' : ''}`;
  }
}

/* ===== Scheduler ===== */
const SILENCE_IDX = SOUND_NAMES.indexOf("Silencer");
const PHRASES_IDX = SOUND_NAMES.indexOf("Phrases"); // A01: Phrase sampler track
let lookAhead = 0.12;
function scheduleSilenceGateEvent(atTime, ch){
  // E06: Silencer ADSR - balanced ranges (allows silence to work, may pop at extreme settings)
  const rawA = (adsr && adsr[ch] ? +adsr[ch].a : 0.015);
  const rawD = (adsr && adsr[ch] ? +adsr[ch].d : 0.010);
  const rawS = (adsr && adsr[ch] ? +adsr[ch].s : 0.20);
  const rawR = (adsr && adsr[ch] ? +adsr[ch].r : 0.025);

  // E06: Constrain to slider ranges: A:10-50ms, D:10-50ms, S:0-0.40, R:10-40ms
  const a = Math.max(0.010, Math.min(0.050, rawA));
  const d = Math.max(0.010, Math.min(0.050, rawD));
  const s = Math.max(0.001, Math.min(0.40, rawS));
  const r = Math.max(0.010, Math.min(0.040, rawR));

  // E07: Get pan position for BPM-synced stereo timing offset (rhythmic!)
  const panValue = (panNode[ch] && panNode[ch].pan) ? panNode[ch].pan.value : 0;
  // E07: Calculate 32nd note duration based on current tempo (rhythmically locked)
  const secondsPerBeat = 60.0 / tempo;
  const thirtySecondNote = (secondsPerBeat / 8); // 32nd note = 1/8 of quarter note
  const maxOffset = thirtySecondNote; // Max offset = one 32nd note
  const offsetL = panValue < 0 ? 0 : panValue * maxOffset; // Pan right = delay left
  const offsetR = panValue > 0 ? 0 : -panValue * maxOffset; // Pan left = delay right

  // E02: Apply to both L and R gates with timing offset
  const applyGate = (gateNode, timeOffset) => {
    const g = gateNode && gateNode.gain ? gateNode.gain : null;
    if (!g) return;
    const startTime = atTime + timeOffset;
    try { g.cancelAndHoldAtTime(startTime); } catch(_){ try{ g.cancelScheduledValues(startTime); }catch(__){} }
    const cur = Math.max(0.0001, g.value);
    g.setValueAtTime(cur, startTime);
    // E02: Exponential ramps for smooth, musical curves (no sharp edges)
    const t1 = startTime + a; g.exponentialRampToValueAtTime(Math.max(0.0001, s), t1);
    const t2 = t1 + d;        g.setValueAtTime(Math.max(0.0001, s), t2);
    const t3 = t2 + r;        g.exponentialRampToValueAtTime(1.0, t3);
  };

  applyGate(silenceGateL, offsetL);
  applyGate(silenceGateR, offsetR);
}

// Global beat counter for phrase recording (counts every 16th note)
let globalBeatCounter = 0;
let phraseRecArmed = false; // Set to true when user clicks Record button
let phraseRecBeatsRecorded = 0;

function scheduler(){
  const spb = 60/tempo, stepDur = spb/4;
  // E01: phrase-scale harmonic bias (Hum only; Follow gate)
  try{ if (typeof hum!=='undefined' && hum.follow) __updateHarmonicBias(); }catch(_){}

  while (nextNoteTime < audioCtx.currentTime + lookAhead){

    // F18/J04: Ghost clock-based trigger (when effect is routed to Ghost OR Phrase Sampler Ghost send is active)
    if (ghostClockEnabled && nextGhostClockTime <= nextNoteTime) {
      const beatSec = 60 / tempo;
      const clockInterval = (beatSec * 4) / ghostClockDivision; // musical division
      // J04: Use PHRASES_IDX if Phrase Sampler Ghost send is active, otherwise use Channel 4 (Bloom)
      const clockChannel = (ghostSendGains[PHRASES_IDX] && ghostSendGains[PHRASES_IDX].gain.value > 0) ? PHRASES_IDX : 4;
      scheduleGhostCluster(clockChannel, nextGhostClockTime, ghostDensity);
      nextGhostClockTime += clockInterval;
    }

    // A06: Phrase recording logic - use precise audio context timing
    // D13: In Link Mode, only start at beginning of full loop to stay in phase
    // Otherwise, start at any beat 1 (every 16 steps)
    const loopLength = (pageCount || 1) * 16; // Total steps in Link Mode loop (2 pages=32, 3 pages=48, etc.)
    const onBeatOne = window.chainMode
      ? (globalBeatCounter % loopLength === 0)  // Link Mode: start at beginning of each loop (0, loopLength, 2*loopLength...)
      : (globalBeatCounter % 16 === 0);         // Normal: start at any beat 1 (0, 16, 32, 48...)

    if (phraseRecArmed && onBeatOne && !phraseRecording) {
      // A06: Start recording and capture exact scheduled time for this beat
      const exactStartTime = nextNoteTime;
      startPhraseRecording(exactStartTime);
      phraseRecBeatsRecorded = 0;
    }

    if (phraseRecording) {
      phraseRecBeatsRecorded++;
      // C13: Stop when we've recorded enough samples (including lookahead offset)
      if (phraseRecLength >= phraseRecTargetSamples) {
        const buffer = stopPhraseRecording();
        if (buffer) {
          const phraseNum = phraseLibrary.length + 1;
          phraseLibrary.push({buffer: buffer, name: `Phrase ${phraseNum}`});
          // Update UI dropdowns and button
          if (typeof updatePhraseDropdowns === 'function') updatePhraseDropdowns();
          // Reset record button UI
          const recBtns = document.querySelectorAll('button');
          recBtns.forEach(btn => {
            if (btn.textContent.includes('Recording Armed')) {
              btn.textContent = 'Record (64 beats)';
              btn.style.backgroundColor = '';
            }
          });
        }
        phraseRecArmed = false;
        phraseRecBeatsRecorded = 0;
      }
    }

    // CR-024: one-pole smooth of ghost density (fast but click-safe)
    ghostDensitySmooth += (ghostDensity - ghostDensitySmooth) * 0.3;
    fxReactSmooth += (fxReact - fxReactSmooth) * 0.25;

    
    const N_STEPS_LOCAL = (typeof N_STEPS !== 'undefined' ? N_STEPS : 16);
    const usingChain = !!window.chainMode && (pageCount|0) > 1;
    const absAligned = ((absStep|0) - ((window.chainPhase|0)>>>0));

    let playPg = currentPage|0;  // Default to current page if not in chain mode

    if (usingChain) {
      // Use track 0 (Kick) as reference for page indicator
      const tRef = 0;

      // Get total loop length for reference track
      // Example: [Page0: 16, Page1: 14] → totalLen = 30
      const totalLen = trackCumulativeLen[tRef] || (N_STEPS_LOCAL * (pageCount|0));

      // Calculate where reference track is in its loop (0 to totalLen-1)
      const counter = ((absAligned % totalLen) + totalLen) % totalLen;

      // Accumulate rail lengths to find which page this counter position is on
      let accumulated = 0;
      for (let pg = 0; pg < (pageCount|0); pg++) {
        // Get rail length for this page (from live data or scene snapshot)
        let pageRailLen;
        if (pg === currentPage) {
          // Current page: use live trackLen
          pageRailLen = trackLen[tRef] || N_STEPS_LOCAL;
        } else {
          // Other pages: use saved scene data
          const pageData = scenes[pg];
          pageRailLen = (pageData && pageData.trackLen && pageData.trackLen[tRef]) || N_STEPS_LOCAL;
        }

        // I12: Account for page repeats
        const repeatCount = pageRepeatCounts[pg] || 1;
        const totalPageLen = pageRailLen * repeatCount;

        // Is counter within this page's range?
        // Example: counter=5, accumulated=0, pageRailLen=16 → 5 < 16, so page 0
        // Example: counter=20, accumulated=16, pageRailLen=14 → 20 < 30, so page 1
        if (counter < accumulated + totalPageLen) {
          playPg = pg;
          break;
        }
        accumulated += totalPageLen;
      }
    }

    // Export for UI and call page indicator update
    window.ui && (window.ui.playPg = playPg);
    if (typeof updatePlayingIndicator==='function'){
      if (usingChain) updatePlayingIndicator(playPg);
      else updatePlayingIndicator(-1);
    }
    // ════════════════════════════════════════════════════════════════════════
for (let ch=0; ch<NUM_SOUNDS; ch++){
      // A7: Use per-track position for polyrhythm
      const pos = getTrackPosition(ch);
      const globalStepIdx = pos.globalStep;
      const localStepIdx = pos.localStep;
      window.ui && (window.ui.stepLocal[ch] = localStepIdx);
    const offMs = (timingOffsetMs && timingOffsetMs[ch]) ? timingOffsetMs[ch][globalStepIdx] : 0;
      const offSec = Math.max(-0.2, Math.min(0.2, offMs/1000));
      const t = nextNoteTime + offSec;
      let willHit = false;
      // A7: Use unified global pattern arrays
      if (pattern && pattern[ch] && probability && probability[ch]) {
        const active = !!pattern[ch][globalStepIdx];
        if (active) {
          let N = probability[ch][globalStepIdx] | 0;
          if (N < 1) N = 1;
          if (!hitCounters[ch] || hitCounters[ch].length < MAX_STEPS) {
            hitCounters[ch] = new Array(MAX_STEPS).fill(0);
          }
          const count = hitCounters[ch][globalStepIdx] | 0;
          willHit = (count % N === 0);
          hitCounters[ch][globalStepIdx] = count + 1;
        }
      }
// Silencer: gate master on actual hits and skip normal voice
      if (ch === SILENCE_IDX) { if (willHit ) scheduleSilenceGateEvent(t, ch); continue; }

      // A01: Phrase sampler - only trigger at 64-step boundaries to prevent overlapping
      if (ch === PHRASES_IDX) {
        // H07: Apply solo logic to Phrase Sampler (same as other tracks)
        const anyTrackSoloed = soloState.some(s => s);
        const phraseShouldPlay = !anyTrackSoloed || soloState[PHRASES_IDX];

        if (!phraseShouldPlay) {
          continue; // Muted by solo - skip this channel
        }

        // Only trigger phrases at the start of each 64-step cycle
        const at64StepBoundary = (globalBeatCounter % 64 === 0);
        if (at64StepBoundary && willHit) {
          const localStep = playhead[PHRASES_IDX];
          // A12: Phrase track is constant across pages - always use steps 0-15
          const phraseIdx = phraseAssignments[localStep];
          if (phraseIdx != null) {
            schedulePhrase(phraseIdx, t, localStep); // Pass slot index for shuffle support
          }
        }
        continue;
      }

      // B04: Solo logic - if any tracks are soloed, only play soloed tracks
      const anyTrackSoloed = soloState.some(s => s);
      const shouldPlay = willHit && (!anyTrackSoloed || soloState[ch]);

      if (shouldPlay) {
        if (ghostSendGains[ch].gain.value > 0) scheduleGhostCluster(ch, t, ghostDensitySmooth);

        // G12: Combine track pitch with step pitch (diatonic mode + quantization)
        let stepPitchValue = (stepPitch && stepPitch[ch] ? stepPitch[ch][globalStepIdx] : 0);

        // G12: Convert scale degree to semitones if diatonic mode is ON
        let stepPitchSemitones;
        if (diatonicEnabled[ch]) {
          // In diatonic mode, stepPitchValue is a scale degree (1=root, 2=2nd, etc.)
          stepPitchSemitones = scaleDegreeToSemitones(stepPitchValue, globalRoot, globalScale);
        } else {
          // In chromatic mode, stepPitchValue is already semitones
          stepPitchSemitones = stepPitchValue;
        }

        // Apply harmonic quantization if enabled for this track
        stepPitchSemitones = quantizePitch(stepPitchSemitones, ch);
        const stepPitchMultiplier = Math.pow(2, stepPitchSemitones / 12);
        const finalPitch = pitches[ch] * stepPitchMultiplier;

        const amt = (morphAmt && morphAmt[ch] ? morphAmt[ch][globalStepIdx] : 0)/100, target = (morphTarget && morphTarget[ch] ? morphTarget[ch][globalStepIdx] : 0);
        morphCrossfade(ch, target, t, finalPitch, amt);
      }
    }
    updateReactiveFX(stepDur);
    nextNoteTime += stepDur;
    for (let __ch=0; __ch<NUM_SOUNDS; __ch++) {
        const N = (typeof N_STEPS !== 'undefined' ? N_STEPS : 16);
        const L = Math.max(1, (trackLen && (trackLen[__ch]|0)) || N);

        // A01: Phrases track advances at 1/64 speed (once per complete 4-bar phrase)
        if (__ch === PHRASES_IDX) {
          // Only increment playhead every 64 steps (one complete phrase cycle)
          if (globalBeatCounter % 64 === 63) {
            playhead[__ch] = (playhead[__ch] + 1) % L;
            // A12 Fix: trackStepCounter must also advance at 1/64 speed for phrases
            trackStepCounter[__ch] = (trackStepCounter[__ch] + 1) % trackCumulativeLen[__ch];
          }
        } else {
          playhead[__ch] = (playhead[__ch] + 1) % L;
          // A3: Increment per-track counters (wraps at cumulative length)
          trackStepCounter[__ch] = (trackStepCounter[__ch] + 1) % trackCumulativeLen[__ch];
        }
      }
      currentStep = (currentStep+1) % N_STEPS;
    if (usingChain) { absStep = (absStep + 1) | 0; }
    globalBeatCounter++; // A01: Increment for phrase recording
    highlight(currentStep);
    // H09: Removed updateDebugDisplay() call
  }
  rafId=requestAnimationFrame(scheduler);
}

function updateReactiveFX(stepDur){
  // React should not be influenced by unsent tracks. We only smooth the knob,
  // and optionally read the Dub-send envelope if available (very gentle).
  const now = audioCtx.currentTime;
  // Smooth fxReact toward the current knob value (keeps legacy code stable if referenced)
  if (typeof fxReactSmooth === 'undefined') fxReactSmooth = 1.0;
  fxReactSmooth += (fxReact - fxReactSmooth) * 0.25;
  // Do not auto-push delayWet or delayFb here; those are controlled by the dedicated handlers.
}


/* ===== UI ===== */
// Phase 4: draggable length rail
function buildLenRail(s, stepsEl){
  try{
    const rail = document.createElement('div'); rail.className = 'lenRail';
    const line = document.createElement('div'); line.className = 'lenRailLine';
    const marker = document.createElement('div'); marker.className = 'lenRailMarker'; marker.tabIndex = 0; marker.setAttribute('role','slider'); marker.setAttribute('aria-label','Track length'); marker.setAttribute('aria-valuemin','1'); marker.setAttribute('aria-valuemax','16');
    const grab = document.createElement('div'); grab.className = 'lenRailGrab';
    rail.appendChild(line); rail.appendChild(marker); rail.appendChild(grab);
    const shade = document.createElement('div'); shade.className='lenShade'; stepsEl.appendChild(shade);
    stepsEl.appendChild(rail);

    function boxes(){ return stepsEl.querySelectorAll('.step'); }
    function rect(el){ return el.getBoundingClientRect(); }
    const MARKER_OFFSET = 5;
    function lenToX(L){
      const b = boxes(); const N = b.length || 16;
      const idx = Math.max(0, Math.min(N-1, (L|0)-1));
      const rSteps = rect(stepsEl); const r = rect(b[idx]);
      return (r.right - rSteps.left);
    }
    function snapLenFromX(x){
      const b = boxes(); const N = b.length || 16;
      const rSteps = rect(stepsEl);
      for (let i=0;i<N;i++){
        const r = rect(b[i]);
        const mid = (r.left - rSteps.left) + r.width/2;
        if (x < mid) return i+1;
      }
      return N;
    }
    function refresh(){
      const L = (trackLen[s]|0);
      const x = lenToX(L);
      marker.style.left = (x + MARKER_OFFSET) + 'px';
      marker.setAttribute('aria-valuenow', String(L));
      try{ shade.style.left = (x + MARKER_OFFSET) + 'px'; }catch(_){}
    }
    function applyLen(L){
      trackLen[s] = Math.max(1, Math.min(16, L|0));
      applyTrackLenUI(s);
      refresh();
      // A3: Recalculate cumulative lengths when rail changes
      calcCumulativeLengths();
    }
    function onDrag(ev){
      const rSteps = rect(stepsEl);
      const x = Math.max(0, Math.min(ev.clientX - rSteps.left, rSteps.width));
      applyLen(snapLenFromX(x));
    }
    grab.addEventListener('pointerdown', ev=>{ grab.setPointerCapture(ev.pointerId); onDrag(ev); });
    grab.addEventListener('pointermove', ev=>{ if (grab.hasPointerCapture && grab.hasPointerCapture(ev.pointerId)) onDrag(ev); });
    grab.addEventListener('pointerup',   ev=>{ try{ grab.releasePointerCapture(ev.pointerId); }catch(_){} });
    marker.addEventListener('keydown', (e)=>{
      if (e.key === 'ArrowLeft') { applyLen((trackLen[s]|0)-1); e.preventDefault(); }
      if (e.key === 'ArrowRight'){ applyLen((trackLen[s]|0)+1); e.preventDefault(); }
      if (e.key === 'Home'){ applyLen(1); e.preventDefault(); }
      if (e.key === 'End'){ applyLen(16); e.preventDefault(); }
    });
    window.addEventListener('resize', refresh);
    refresh();
  }catch(_){}
}

const grid = document.getElementById('grid');
function buildUI(){
  /* Maja controls */
  const tiltEl = document.getElementById('majaTilt');
  const driveEl = document.getElementById('majaDrive');
  const airEl = document.getElementById('majaAir');
  const lfoRateEl = document.getElementById('majaLfoRate');
  const lfoDepthEl = document.getElementById('majaLfoDepth');
  const lfoTargetEl = document.getElementById('majaLfoTarget');
  function updateTilt(){
    let v = +tiltEl.value;
    // keep some curvature but don't over-expand the ends
    v = Math.max(-1, Math.min(1, v * 1.1));
    const minHz = 100; // F20: Lowered back down - detune can't cause negative freq issues
    const maxHz = 6000;
    const cutoff = minHz * Math.pow(maxHz / minHz, (v+1)/2);
    const now = audioCtx.currentTime;

    // F16: Use smooth transitions instead of hard jumps to prevent filter discontinuities
    majaLP.frequency.setTargetAtTime(cutoff, now, 0.008); // 8ms smooth
    majaHP.frequency.setTargetAtTime(cutoff, now, 0.008);

    // true seesaw: no extra gain above 1.0, deep cut on the opposite side
    const base = 0.5;
    const boost = 0.5;
    let lpw, hpw;
    if (v >= 0){
      // tilt right: emphasise highs, reduce lows
      const t = v;
      hpw = base + boost * t;   // 0.5 -> 1.0
      lpw = base - boost * t;   // 0.5 -> 0.0
    } else {
      // tilt left: emphasise lows, reduce highs
      const t = -v;
      lpw = base + boost * t;   // 0.5 -> 1.0
      hpw = base - boost * t;   // 0.5 -> 0.0
    }
    majaMixLP.gain.setTargetAtTime(lpw, now, 0.008); // F16: Smooth gain changes too
    majaMixHP.gain.setTargetAtTime(hpw, now, 0.008);
  }
  function updateDrive(){
  let x = +driveEl.value;
  x = Math.max(0, Math.min(1, x));

  // Make most of the range gentle, ramp harder near the top
  const shaped = Math.pow(x, 1.3);   // emphasizes the top end of the slider

  // Map to waveshaper 'amount' range:
  // - at x=0  → amount ≈ 0.4  (barely any saturation)
  // - at x=1  → amount ≈ 2.4  (hotter than the old 1.8)
  const amount = 0.4 + shaped * 2.0;

  majaDrive.curve = makeTanhCurve(amount);
}
    // "Spread" slider: controls width of auto-pan driven by its own LFO
  function updateAir(){
    let v = +airEl.value || 0;

    // Normalise to 0..1 and add a tiny curve so the first half is gentle
    let norm = Math.max(0, Math.min(1, v / 6));
    const depth = Math.pow(norm, 1.15);

    try {
      if (majaPanAmt && majaPanAmt.gain) {
        const now = audioCtx.currentTime;
        try { majaPanAmt.gain.cancelAndHoldAtTime(now); } 
        catch(_) { try { majaPanAmt.gain.cancelScheduledValues(now); } catch(__) {} }
        majaPanAmt.gain.setTargetAtTime(depth, now, 0.03);
      }
    } catch(_) {}
  }

  function updateLfo(){
  const rate = +lfoRateEl.value;
  let depth = +lfoDepthEl.value;

  // F20: Restore original spice - detune is pop-free so we can be aggressive
  depth = Math.max(0, Math.min(1, depth));
  const shaped = Math.pow(depth, 1.0);  // Linear - full expression, no mellowing

  // Set LFO speed with tiny envelope to avoid pops
  const now = audioCtx.currentTime;
  majaLFO.frequency.setTargetAtTime(rate, now, 0.015); // 15ms smoothing
  // Pan LFO follows at half the main LFO rate
  try {
    if (majaPanLFO) {
      const panRate = Math.max(0.01, rate * 0.5);
      majaPanLFO.frequency.setTargetAtTime(panRate, now, 0.015); // 15ms smoothing
    }
  } catch(_) {}


  // Clear previous routing safely
  try { majaLfoAmt.disconnect(); } catch(_) {}

  if (lfoTargetEl.value === 'cutoff') {
    // F20: Cranked up to 5 octaves for maximum spice (detune is pop-free!)
    const maxCents = 6000; // 5 octaves (1200 cents = 1 octave)
    const centsRange = maxCents * shaped; // Unipolar LFO: modulates upward only

    majaLfoAmt.gain.setTargetAtTime(centsRange, now, 0.015);

    // Connect to DETUNE instead of FREQUENCY
    majaLFO.connect(majaLfoAmt);
    try {
      majaLfoAmt.connect(majaLP.detune);
      majaLfoAmt.connect(majaHP.detune);
    } catch(_) {}
  } else {
    // Wet LFO: make the extremes more obvious without being insane at low depth
    const maxWetRange = 1.2; // was 0.9
    const wetRange = maxWetRange * shaped;

    majaLfoAmt.gain.setTargetAtTime(wetRange, now, 0.015); // 15ms smoothing to avoid pops

    majaLFO.connect(majaLfoAmt);
    try {
      majaLfoAmt.connect(majaWet.gain);
    } catch(_) {}
  }
}

  [tiltEl, driveEl, airEl, lfoRateEl, lfoDepthEl, lfoTargetEl].forEach(el=> el.addEventListener('input', ()=>{ updateTilt(); updateDrive(); updateAir(); updateLfo(); }));
  updateTilt(); updateDrive(); updateAir(); updateLfo();

  /* Dub UI — time fractions only (UI; audio graph unchanged) */
  const delayTimeEl = document.getElementById('delayTime');
  const delayTimeVal = document.getElementById('delayTimeVal');

  let lastDelayIdx = 3; // track previous index for duck detection (K7)

  function updateDelayTimeUI(idx){
    const FRACTIONS = [
      {name:'1/64', beats:0.0625},
      {name:'1/32', beats:0.125},
      {name:'1/16', beats:0.25},
      {name:'1/8', beats:0.5},
      {name:'3/16', beats:0.75},
      {name:'1/4', beats:1},
      {name:'5/16', beats:1.25},
      {name:'3/8', beats:1.5},
      {name:'7/16', beats:1.75},
      {name:'1/2', beats:2},
      {name:'9/16', beats:2.25},
      {name:'5/8', beats:2.5},
      {name:'11/16', beats:2.75},
      {name:'3/4', beats:3},
      {name:'13/16', beats:3.25},
      {name:'7/8', beats:3.5},
      {name:'15/16', beats:3.75},
      {name:'1', beats:4},
      {name:'17/16', beats:4.25},
      {name:'9/8', beats:4.5},
      {name:'19/16', beats:4.75},
      {name:'5/4', beats:5},
      {name:'21/16', beats:5.25},
      {name:'11/8', beats:5.5},
      {name:'23/16', beats:5.75},
      {name:'3/2', beats:6},
      {name:'25/16', beats:6.25},
      {name:'13/8', beats:6.5},
      {name:'27/16', beats:6.75},
      {name:'7/4', beats:7},
      {name:'29/16', beats:7.25},
      {name:'15/8', beats:7.5},
      {name:'31/16', beats:7.75},
      {name:'2', beats:8}
    ];;
    const i = Math.max(0, Math.min(FRACTIONS.length-1, (idx|0)));
    const frac = FRACTIONS[i];
    const bpmEl = document.getElementById('tempo');
    const bpm = Math.max(20, Math.min(300, bpmEl ? (+bpmEl.value||120) : (typeof tempo!=='undefined'?tempo:120)));
    const secPerBeat = 60 / bpm;
    const delaySec = frac.beats * secPerBeat;
    const now = audioCtx.currentTime;

    // K7: Detect large jumps (>4 steps) and apply gentle duck
    const jumpSize = Math.abs(i - lastDelayIdx);
    const isLargeJump = jumpSize > 4;

    if (isLargeJump) {
      // Gentle duck: -3dB for 30ms, then recover
      try {
        delayWet.gain.cancelScheduledValues(now);
        const currentGain = delayWet.gain.value;
        delayWet.gain.setValueAtTime(currentGain, now);
        delayWet.gain.linearRampToValueAtTime(currentGain * 0.5, now + 0.03);  // -3dB duck
        delayWet.gain.linearRampToValueAtTime(currentGain, now + 0.06);        // recover
      } catch(_) {}
    }

    try { delayNode.delayTime.cancelAndHoldAtTime(now); } catch(_){ try{ delayNode.delayTime.cancelScheduledValues(now); }catch(__){} }
    try { delayNode.delayTime.setTargetAtTime(delaySec, now, 0.05); } catch(_){ delayNode.delayTime.value = delaySec; }  // K7: 0.05 (was 0.02)

    lastDelayIdx = i; // remember for next change
    if (delayTimeVal) delayTimeVal.textContent = frac.name;
    try { const w = document.getElementById('delayWarble'); if (w) applyDubWarble(+w.value||0); } catch(_) {}
  }
  if (delayTimeEl){
    delayTimeEl.addEventListener('input', e=> updateDelayTimeUI(+e.target.value));
    updateDelayTimeUI(+delayTimeEl.value || 3);
  
  try{
    const fbInitEl = document.getElementById('delayFb');
    if (fbInitEl){
      const evt = new Event('input'); fbInitEl.dispatchEvent(evt);
    }
  }catch(_){}
}

// Initialize feedback display on load
try {
  const fbInit = document.getElementById('delayFb');
  if (fbInit) {
    const initEvt = new Event('input');
    fbInit.dispatchEvent(initEvt);
  }
} catch(_) {}
document.getElementById('delayFb').addEventListener('input', e=>{
  const now = audioCtx.currentTime;
  let raw = +e.target.value || 0;
  raw = Math.max(0, Math.min(0.95, raw));

  // G01: Piecewise feedback mapping (reduced max from 0.47 to 0.40)
  // - Left 35% of slider (norm <= 0.35) : 0 → 0.30
  // - Right 65% (norm > 0.35)           : 0.30 → 0.40, with very fine control
  const norm = raw / 0.95; // normalized slider position 0..1
  let fb;
  if (norm <= 0.35) {
    const x = norm / 0.35;         // 0..1 over left 35%
    const a = 1.3;
    fb = 0.30 * Math.pow(x, a); // 0..0.30
  } else {
    const u = (norm - 0.35) / 0.65; // 0..1 over right 65%
    const b = 2.0;
    fb = 0.30 + 0.10 * Math.pow(u, b); // 0.30..0.40
  }

  try { delayFb.gain.cancelAndHoldAtTime(now); } catch(_){ try{delayFb.gain.cancelScheduledValues(now);}catch(__){} }
  delayFb.gain.setTargetAtTime(fb, now, 0.1);

  // Update feedback display
  const fbDisplay = document.getElementById('delayFbVal');
  if (fbDisplay) fbDisplay.textContent = (fb * 100).toFixed(0) + '%';

  // Drive mapping tied to feedback (subtle to hot)
  const drive = 0.25 + (raw/0.95)*0.65;
  try { if (typeof delaySat!=='undefined' && delaySat) delaySat.curve = makeTanhCurve(drive); } catch(_){ }

  // Dynamic LP tighten with feedback (10k -> ~5k)
  const lpHz = 10000 - (raw/0.95) * (10000 - 5000);
  try { delayTone.frequency.cancelAndHoldAtTime(now); } catch(_){ try{delayTone.frequency.cancelScheduledValues(now);}catch(__){} }
  try { delayTone.frequency.setTargetAtTime(lpHz, now, 0.1); } catch(_){ try{ delayTone.frequency.value = lpHz; }catch(__){} }

  // Wet autotrim (0 to -1 dB near the very top)
  const trimDb = (raw > 0.90) ? -1 * ((raw - 0.90)/0.05) : 0;
  const trim = Math.pow(10, trimDb/20);
  try { delayWet.gain.setTargetAtTime(0.55 * trim, now, 0.1); } catch(_){ }
});
document.getElementById('delayTone').addEventListener('input', e=>{
    const now = audioCtx.currentTime;
    try { delayTone.frequency.cancelAndHoldAtTime(now); } catch(_){ try{delayTone.frequency.cancelScheduledValues(now);}catch(__){} }
    delayTone.frequency.setTargetAtTime(+e.target.value, now, 0.02);
  });

  /* React UI */
  (function(){
  const el = document.getElementById('fxReact');
  if (!el) return;
  let raf = 0, pending = null;
  const push = ()=>{ if (pending==null) return; fxReact = pending; applyDubReact(pending); pending=null; raf=0; };
  el.addEventListener('input', e=>{ pending = +e.target.value; if (!raf) raf = requestAnimationFrame(push); });
  // Initialize on load
  applyDubReact(+el.value||1.2);
  // Re-apply when feedback changes
  const fbEl = document.getElementById('delayFb');
  if (fbEl) fbEl.addEventListener('input', ()=> applyDubReact(fxReact));
})();

  /* Warble UI */
  (function(){
  const el = document.getElementById('delayWarble');
  if (!el) return;
  let raf = 0, pending = null;
  const push = ()=>{ if (pending==null) return; applyDubWarble(pending); pending=null; raf=0; };
  el.addEventListener('input', e=>{ pending = +e.target.value; if (!raf) raf = requestAnimationFrame(push); });
  // Initialize on load
  applyDubWarble(+el.value||0);
})();

  /* Reverse Ghost UI */
  document.getElementById('ghostLen').addEventListener('input', e=>{ ghostLen=Math.max(0.1,+e.target.value); });
  document.getElementById('ghostPitch').addEventListener('input', e=>{ ghostPitchSemis = -(+e.target.value); }); // H21: Negate so up=higher pitch
  document.getElementById('ghostBoost').addEventListener('input', e=>{ ghostBoost=+e.target.value; });
  (function(){
  const el = document.getElementById('ghostDensity');
  if (!el) return;
  let raf = 0, pending = null;
  const push = ()=>{ if (pending==null) return; ghostDensity = pending; pending=null; raf=0; };
  el.addEventListener('input', e=>{
    pending = +e.target.value;
    if (!raf) raf = requestAnimationFrame(push);
  });
})();
  document.getElementById('ghostReverse').addEventListener('input', e=>{ ghostReverse=+e.target.value; });
  document.getElementById('ghostOblique').addEventListener('input', e=>{ ghostOblique=+e.target.value; });
  document.getElementById('ghostRev').addEventListener('input', e=>{ ghostRevWetCtrl=+e.target.value; });

  // F18: Ghost clock division dropdown
  document.getElementById('ghostClock').addEventListener('change', e=>{ ghostClockDivision=+e.target.value; });

  /* Harmonic Gate UI */
  (function(){
    const mixEl = document.getElementById('hgMix');
    const qEl = document.getElementById('hgQ');
    const resEl = document.getElementById('hgResonance');
    const gainEl = document.getElementById('hgGain');
    const threshEl = document.getElementById('hgThreshold');
    const attackEl = document.getElementById('hgAttack');
    const releaseEl = document.getElementById('hgRelease');

    function updateWetGain() {
      const now = audioCtx.currentTime;
      const wetGain = hgMix * hgGain;  // Mix × Gain
      hgDry.gain.setTargetAtTime(1.0 - hgMix, now, 0.05);
      hgWet.gain.setTargetAtTime(wetGain, now, 0.05);
    }

    if (mixEl) {
      mixEl.addEventListener('input', e => {
        hgMix = +e.target.value;
        updateWetGain();
      });
    }

    if (gainEl) {
      gainEl.addEventListener('input', e => {
        hgGain = +e.target.value;
        updateWetGain();
      });
    }

    if (qEl) {
      qEl.addEventListener('input', e => {
        hgQ = +e.target.value;
        // Update all resonator Q values
        hgResonators.forEach(bp => {
          bp.Q.value = hgQ;
        });
      });
    }

    if (resEl) {
      resEl.addEventListener('input', e => {
        hgResonance = +e.target.value;
        // Resonance affects the output gain of the resonator sum (more extreme: 1x to 10x)
        if (hgResonatorSum) {
          const normGain = Math.max(0.1, Math.min(1.0, 1.0 / Math.sqrt(hgResonators.length / 10)));
          const resGain = normGain * (1.0 + hgResonance * 9.0);  // 1x to 10x range
          hgResonatorSum.gain.value = resGain;
        }
      });
    }

    if (threshEl) {
      threshEl.addEventListener('input', e => {
        hgThreshold = +e.target.value;
        // Threshold controls when the gate opens (envelope follower)
      });
    }

    if (attackEl) {
      attackEl.addEventListener('input', e => {
        hgAttack = +e.target.value;
      });
    }

    if (releaseEl) {
      releaseEl.addEventListener('input', e => {
        hgRelease = +e.target.value;
      });
    }

    // Initialize values
    if (mixEl) hgMix = +mixEl.value;
    if (gainEl) hgGain = +gainEl.value;
    if (qEl) hgQ = +qEl.value;
    if (resEl) hgResonance = +resEl.value;
    if (threshEl) hgThreshold = +threshEl.value;
    if (attackEl) hgAttack = +attackEl.value;
    if (releaseEl) hgRelease = +releaseEl.value;

    // Set initial gains
    hgDry.gain.value = 1.0 - hgMix;
    hgWet.gain.value = hgMix * hgGain;
  })();

/* Grid + per-row sends + sample load + per-track Morph Mode + Volume/Tone */
  for (let s=0;s<NUM_SOUNDS;s++){
    const row = document.createElement('div'); row.className='track';
    if (s === PHRASES_IDX) row.classList.add('noAdsr');

    // G18: No .leftCol wrapper - create nameAndSends and sampleCol as direct children
    const nameAndSends = document.createElement('div'); nameAndSends.className='nameAndSends';
    const name = document.createElement('div'); name.textContent = SOUND_NAMES[s];
    nameAndSends.appendChild(name);

    const sendCol = document.createElement('div'); sendCol.className='sendCol';
    const mkSend = (label, gainNode, trackIdx)=>{
      const block = document.createElement('div'); block.className='sendBlock';
      const lab = document.createElement('div'); lab.className='lab'; lab.textContent = label;
      const ctl = document.createElement('input'); ctl.type='range'; ctl.min=0; ctl.max=1; ctl.step=0.01; ctl.value=0;
      ctl.addEventListener('input', e=>{
        gainNode.gain.setValueAtTime(+e.target.value, audioCtx.currentTime);
        // J05: Enable Ghost Clock when Phrase Sampler's Ghost send is active
        if (trackIdx === PHRASES_IDX && label === 'Ghost') {
          const sendValue = +e.target.value;
          const clockFooter = document.getElementById('ghostClockFooter');

          if (sendValue > 0) {
            // Enable clock
            if (!ghostClockEnabled) {
              if (typeof isPlaying !== 'undefined' && isPlaying) {
                nextGhostClockTime = audioCtx.currentTime;
              }
              ghostClockEnabled = true;
            }
            // J05: Update UI to show clock is active
            if (clockFooter) {
              clockFooter.classList.remove('inactive');
            }
          } else if (sendValue === 0) {
            // Disable clock (only if no effect is connected to Ghost)
            const fxContainer = document.querySelector('.fxrow.fxbar');
            let hasEffectConnection = false;

            if (fxContainer) {
              const modules = Array.from(fxContainer.querySelectorAll('.fxModule'));
              const ghostIndex = modules.findIndex(m => m.dataset.effect === 'ghost');
              if (ghostIndex > 0) {
                const prevModule = modules[ghostIndex - 1];
                const prevEffectName = prevModule.dataset.effect;
                const connections = window.connections || {};
                hasEffectConnection = connections[prevEffectName];
              }
            }

            if (!hasEffectConnection) {
              ghostClockEnabled = false;
              // J05: Update UI to show clock is inactive
              if (clockFooter) {
                clockFooter.classList.add('inactive');
              }
            }
          }
        }
      });
      block.appendChild(lab); block.appendChild(ctl); return block;
    };
    sendCol.appendChild(mkSend('Maja',  majaSendGains[s], s));
    sendCol.appendChild(mkSend('Dub', delaySendGains[s], s));
    sendCol.appendChild(mkSend('Ghost', ghostSendGains[s], s));
    sendCol.appendChild(mkSend('Hum', humSendGains[s], s));
    sendCol.appendChild(mkSend('Gate', hgSendGains[s], s));

    if (SOUND_NAMES[s] !== "Silencer") {
      nameAndSends.appendChild(sendCol);

      const pitchWrap = document.createElement('div');
      pitchWrap.className = 'sendBlock';
      pitchWrap.style.marginTop = '8px';

      const pitchLabel = document.createElement('div');
      pitchLabel.className = 'lab';
      pitchLabel.textContent = 'Pitch';
      pitchLabel.style.display='block';
      pitchLabel.style.fontSize='11px';
      pitchLabel.style.color='#9fb4d6';

      const pitchRng = document.createElement('input');
      pitchRng.type = 'range';
      pitchRng.className = 'pitchSlider';
      pitchRng.min = -12;
      pitchRng.max = 12;
      pitchRng.step = 0.1;
      pitchRng.dataset.ch = s;

      const currentRate = (pitches[s] != null ? pitches[s] : 1);
      const currentSt = 12 * Math.log2(currentRate || 1);
      pitchRng.value = currentSt;

      const pitchOut = document.createElement('span');
      pitchOut.className = 'small';
      pitchOut.style.minWidth = '44px';
      pitchOut.style.textAlign = 'right';

      let lastPitchSt = pitchRng.value ? +pitchRng.value : 0;

      function sliderStToRate(st){
        return Math.pow(2, st / 12);
      }

      function updatePitchOut(){
        const st = +pitchRng.value || 0;
        pitchOut.textContent = `${st>=0?'+':''}${st.toFixed(1)} st`;
      }

      pitchRng.addEventListener('input', e=>{
        const ch = +e.target.dataset.ch;
        const st = +e.target.value || 0;
        const rate = sliderStToRate(st);
        pitches[ch] = rate;
        updatePitchOut();
      });

      pitchOut.addEventListener('click', ()=>{
        pitchRng.value = String(lastPitchSt);
        const st = +pitchRng.value || 0;
        const rate = sliderStToRate(st);
        pitches[s] = rate;
        updatePitchOut();
      });

      pitchRng.addEventListener('pointerdown', ()=>{
        lastPitchSt = +pitchRng.value || 0;
      });

      // I07: Double-click to reset pitch to 0
      pitchRng.addEventListener('dblclick', ()=>{
        pitchRng.value = '0';
        const ch = +pitchRng.dataset.ch;
        pitches[ch] = 1.0; // 0 semitones = rate 1.0
        updatePitchOut();
      });

      updatePitchOut();
      pitchWrap.appendChild(pitchLabel);
      pitchWrap.appendChild(pitchRng);
      pitchWrap.appendChild(pitchOut);
      nameAndSends.appendChild(pitchWrap);
    }

    // E01: AIFF to WAV converter (decodeAudioData doesn't support AIFF in all browsers)
    function aiffToWav(arrayBuffer) {
      const view = new DataView(arrayBuffer);
      // Check if this is an AIFF file (starts with "FORM" and contains "AIFF")
      const formID = String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3));
      const aiffID = String.fromCharCode(view.getUint8(8), view.getUint8(9), view.getUint8(10), view.getUint8(11));
      if (formID !== 'FORM' || (aiffID !== 'AIFF' && aiffID !== 'AIFC')) {
        return arrayBuffer; // Not AIFF, return as-is
      }

      // Parse AIFF chunks to find COMM (common) and SSND (sound data)
      let numChannels, sampleRate, bitsPerSample, numSampleFrames;
      let soundDataOffset, soundDataSize;

      let offset = 12; // Start after FORM header
      while (offset < view.byteLength - 8) {
        const chunkID = String.fromCharCode(view.getUint8(offset), view.getUint8(offset+1), view.getUint8(offset+2), view.getUint8(offset+3));
        const chunkSize = view.getUint32(offset + 4, false); // Big-endian

        if (chunkID === 'COMM') {
          numChannels = view.getUint16(offset + 8, false);
          numSampleFrames = view.getUint32(offset + 10, false);
          bitsPerSample = view.getUint16(offset + 14, false);
          // Sample rate is stored as 80-bit extended precision - simplified extraction
          const exponent = view.getUint16(offset + 16, false);
          const mantissa = view.getUint32(offset + 18, false);
          sampleRate = mantissa * Math.pow(2, exponent - 16383 - 31);
        } else if (chunkID === 'SSND') {
          const ssndOffset = view.getUint32(offset + 8, false); // Offset to sound data within chunk
          soundDataOffset = offset + 16 + ssndOffset;
          soundDataSize = chunkSize - 8 - ssndOffset;
        }

        offset += 8 + chunkSize;
        if (chunkSize % 2) offset++; // Chunks are word-aligned
      }

      if (!numChannels || !soundDataOffset) {
        throw new Error('Invalid AIFF file: missing COMM or SSND chunk');
      }

      // Create WAV file
      const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
      const blockAlign = numChannels * (bitsPerSample / 8);
      const wavSize = 44 + soundDataSize;
      const wavBuffer = new ArrayBuffer(wavSize);
      const wavView = new DataView(wavBuffer);
      const wavBytes = new Uint8Array(wavBuffer);

      // Write WAV header
      const writeString = (offset, str) => {
        for (let i = 0; i < str.length; i++) wavView.setUint8(offset + i, str.charCodeAt(i));
      };

      writeString(0, 'RIFF');
      wavView.setUint32(4, wavSize - 8, true); // Little-endian
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      wavView.setUint32(16, 16, true); // fmt chunk size
      wavView.setUint16(20, 1, true); // PCM format
      wavView.setUint16(22, numChannels, true);
      wavView.setUint32(24, sampleRate, true);
      wavView.setUint32(28, byteRate, true);
      wavView.setUint16(32, blockAlign, true);
      wavView.setUint16(34, bitsPerSample, true);
      writeString(36, 'data');
      wavView.setUint32(40, soundDataSize, true);

      // Copy and convert audio data from big-endian (AIFF) to little-endian (WAV)
      const bytesPerSample = bitsPerSample / 8;
      for (let i = 0; i < soundDataSize; i += bytesPerSample) {
        if (bytesPerSample === 1) {
          // 8-bit: no endian conversion needed
          wavView.setUint8(44 + i, view.getUint8(soundDataOffset + i));
        } else if (bytesPerSample === 2) {
          // 16-bit: convert big-endian to little-endian
          wavView.setInt16(44 + i, view.getInt16(soundDataOffset + i, false), true);
        } else if (bytesPerSample === 3) {
          // 24-bit: convert big-endian to little-endian
          const b1 = view.getUint8(soundDataOffset + i);
          const b2 = view.getUint8(soundDataOffset + i + 1);
          const b3 = view.getUint8(soundDataOffset + i + 2);
          wavView.setUint8(44 + i, b3);
          wavView.setUint8(44 + i + 1, b2);
          wavView.setUint8(44 + i + 2, b1);
        } else if (bytesPerSample === 4) {
          // 32-bit: convert big-endian to little-endian
          wavView.setInt32(44 + i, view.getInt32(soundDataOffset + i, false), true);
        }
      }

      return wavBuffer;
    }

    const sampleCol = document.createElement('div'); sampleCol.className='sampleCol';
    const btnrow = document.createElement('div'); btnrow.className='btnrow';
    const loadBtn = document.createElement('button'); loadBtn.textContent='Load Sample';
    const clearBtn = document.createElement('button'); clearBtn.textContent='Clear';
    const fi = document.createElement('input'); fi.type='file'; fi.accept='.wav,.aiff,.aif,.WAV,.AIFF,.AIF'; fi.style.display='none';
    const info = document.createElement('div'); info.className='sampleInfo'; info.textContent='(no sample)';
    loadBtn.addEventListener('click', ()=> fi.click());
    clearBtn.addEventListener('click', ()=>{ sampleBufs[s]=null; sampleMeta[s]=null; info.textContent='(no sample)'; });
    fi.addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if (!f) return;
      try {
        const ab = await f.arrayBuffer();
        const convertedAB = aiffToWav(ab); // E01: Convert AIFF to WAV if needed
        const decoded = await audioCtx.decodeAudioData(convertedAB);
        // E01: Keep original channel count (stereo or mono)
        sampleBufs[s] = decoded;
        sampleMeta[s] = {name:f.name, duration: decoded.duration, channels: decoded.numberOfChannels};
        const shortName = f.name.length>10 ? (f.name.slice(0,10) + '…') : f.name;
        const chanDesc = decoded.numberOfChannels === 1 ? 'mono' : decoded.numberOfChannels === 2 ? 'stereo' : `${decoded.numberOfChannels}ch`;
        info.textContent = `${shortName} (${decoded.duration.toFixed(2)}s, ${chanDesc})`;
      } catch(err) {
        console.error('Failed to decode audio file:', f.name, err);
        info.textContent = `Error: ${err.message || 'Could not decode file'}`;
      }
    });
    btnrow.appendChild(loadBtn); btnrow.appendChild(clearBtn);
    if (SOUND_NAMES[s] === "Silencer"){
      loadBtn.disabled = true; clearBtn.disabled = true; fi.disabled = true;
      loadBtn.title = "Disabled for Silencer"; clearBtn.title = "Disabled for Silencer";
      info.textContent = "";
    }
    

    /* Volume fader (−60..+12 dB, default 0 dB) */
    /* H04: Label above, slider full-width, readout below */
    const volWrap = document.createElement('div'); volWrap.className='btnrow'; volWrap.style.flexDirection='column'; volWrap.style.alignItems='flex-start'; volWrap.style.width='100%';
    const volLab = document.createElement('div'); volLab.className='small'; volLab.textContent='Volume';
    const vol = document.createElement('input'); vol.type='range'; vol.min=-60; vol.max=12; vol.step=0.1; vol.value=0; vol.className='trackSlider'; vol.style.width='100%'; /* H04: full width */
    const volRead = document.createElement('div'); volRead.className='small'; volRead.style.textAlign='center'; /* H04: centered below slider */
    function updateVol(){
      const db = +vol.value;
      const targetGain = Math.max(0.0001, dbToGain(db));
      const now = audioCtx.currentTime;
      // D16: Like HUM controls - no cancel, just smooth transition (300ms time constant)
      volControlSources[s].offset.setTargetAtTime(targetGain, now, 0.300);
      volRead.textContent = `${db.toFixed(1)} dB`;
    }
    vol.addEventListener('input', updateVol); updateVol();

    // B04: Double-click volume slider to solo track
    if (SOUND_NAMES[s] !== "Silencer") {
      vol.addEventListener('dblclick', () => {
        soloState[s] = !soloState[s];
        // Visual feedback: add glow when soloed
        if (soloState[s]) {
          vol.style.outline = '2px solid #ffd700';
          vol.style.outlineOffset = '2px';
          vol.style.filter = 'drop-shadow(0 0 8px rgba(255, 215, 0, 0.6))';
          volLab.textContent = 'Volume (SOLO)';
          volLab.style.color = '#ffd700';
          volLab.style.fontWeight = 'bold';
        } else {
          vol.style.outline = '';
          vol.style.outlineOffset = '';
          vol.style.filter = '';
          volLab.textContent = 'Volume';
          volLab.style.color = '';
          volLab.style.fontWeight = '';
        }
      });
    }

    /* H04: Label, then full-width slider, then readout below */
    volWrap.appendChild(volLab); volWrap.appendChild(vol); volWrap.appendChild(volRead);

    /* Pan slider (L↔R) under Volume */
    /* H04: Label above, slider full-width, readout below */
    const panWrap = document.createElement('div'); panWrap.className='btnrow'; panWrap.style.flexDirection='column'; panWrap.style.alignItems='flex-start'; panWrap.style.width='100%';
    const panLab = document.createElement('div'); panLab.className='small'; panLab.textContent='Pan';
    const pan = document.createElement('input'); pan.type='range'; pan.min=-1; pan.max=1; pan.step=0.01; pan.value=0; pan.className='trackSlider'; pan.style.width='100%'; /* H04: full width */
    const panRead = document.createElement('div'); panRead.className='small'; panRead.style.textAlign='center'; /* H04: centered below slider */
    function updatePan(){ const v = +pan.value; if (panNode[s] && panNode[s].pan) panNode[s].pan.setValueAtTime(v, audioCtx.currentTime); panRead.textContent = v.toFixed(2); }
    pan.addEventListener('input', updatePan); updatePan();
    /* H04: Label, then full-width slider, then readout below */
    panWrap.appendChild(panLab); panWrap.appendChild(pan); panWrap.appendChild(panRead);

    /* H04: Tone is handled by the dial injector (inject() function) - NOT a slider */

    /* B09: Autofill pattern presets */
    const autofillWrap = document.createElement('div'); autofillWrap.className='btnrow';
    const autofillLab = document.createElement('div'); autofillLab.className='small'; autofillLab.textContent='Autofill';
    const autofillSel = document.createElement('select'); autofillSel.style.width='90px'; /* G05: increased to 90px to prevent expansion on click */
    autofillSel.innerHTML = `
      <option value="">—</option>
      <option value="clear">Clear</option>
      <option value="downbeats">Downbeats</option>
      <option value="sparse">Sparse Pair</option>
      <option value="offbeat">Offbeat</option>
      <option value="triplet">Triplet</option>
      <option value="3over">3-over</option>
      <option value="5over">5-over</option>
      <option value="yugen">Yūgen</option>
    `;

    autofillSel.addEventListener('change', (e) => {
      const preset = e.target.value;
      if (!preset) return;

      const trackIdx = s;
      // A12: Phrase track is constant across pages - always use offset 0
      const pageOffset = (trackIdx === PHRASES_IDX) ? 0 : (currentPage * N_STEPS);
      const railLen = Math.max(1, trackLen[trackIdx] || N_STEPS);

      // Clear all timing offsets for current page first
      for (let i = 0; i < N_STEPS; i++) {
        timingOffsetMs[trackIdx][pageOffset + i] = 0;
      }

      if (preset === 'clear') {
        // G01: Clear all hits AND reset all parameters to defaults on current page
        for (let i = 0; i < N_STEPS; i++) {
          pattern[trackIdx][pageOffset + i] = false;
          timingOffsetMs[trackIdx][pageOffset + i] = 0;
          probability[trackIdx][pageOffset + i] = 1;    // Interval: default 1
          morphTarget[trackIdx][pageOffset + i] = 0;    // Morph To: default 0
          morphAmt[trackIdx][pageOffset + i] = 0;       // Amount: default 0
          stepPitch[trackIdx][pageOffset + i] = 0;      // Pitch: default 0
        }
      }
      else if (preset === 'downbeats') {
        // Hit every 4 steps: [X···X···X···X···]
        for (let i = 0; i < railLen; i++) {
          pattern[trackIdx][pageOffset + i] = (i % 4 === 0);
        }
        for (let i = railLen; i < N_STEPS; i++) {
          pattern[trackIdx][pageOffset + i] = false;
        }
      }
      else if (preset === 'sparse') {
        // Two hits: steps 0 and 8 (if rail allows)
        for (let i = 0; i < N_STEPS; i++) {
          pattern[trackIdx][pageOffset + i] = false;
        }
        pattern[trackIdx][pageOffset + 0] = true;
        if (railLen > 8) {
          pattern[trackIdx][pageOffset + 8] = true;
        }
      }
      else if (preset === 'offbeat') {
        // B12: Hits on the offbeats (steps 2, 6, 10, 14) - the "ands" of each beat
        for (let i = 0; i < N_STEPS; i++) {
          pattern[trackIdx][pageOffset + i] = false;
        }
        const offbeats = [2, 6, 10, 14];
        offbeats.forEach(step => {
          if (step < railLen) {
            pattern[trackIdx][pageOffset + step] = true;
          }
        });
      }
      else if (preset === 'triplet') {
        // Three consecutive hits with timing: [····XXX·········]
        // First: +30ms (late), Middle: 0ms, Last: -30ms (early)
        for (let i = 0; i < N_STEPS; i++) {
          pattern[trackIdx][pageOffset + i] = false;
        }
        // Random start position (0 to railLen-3)
        const maxStart = Math.max(0, railLen - 3);
        const start = Math.floor(Math.random() * (maxStart + 1));

        if (railLen >= 3) {
          pattern[trackIdx][pageOffset + start] = true;
          pattern[trackIdx][pageOffset + start + 1] = true;
          pattern[trackIdx][pageOffset + start + 2] = true;

          timingOffsetMs[trackIdx][pageOffset + start] = 30;      // First: late
          timingOffsetMs[trackIdx][pageOffset + start + 1] = 0;   // Middle: on-grid
          timingOffsetMs[trackIdx][pageOffset + start + 2] = -30; // Last: early
        }
      }
      else if (preset === '3over') {
        // B15: Euclidean 3-over with perfect timing - 3 hits evenly distributed
        for (let i = 0; i < N_STEPS; i++) {
          pattern[trackIdx][pageOffset + i] = false;
        }
        const numHits = 3;
        const stepDurationMs = 125; // Assumes 120 BPM (125ms per 16th note)

        for (let i = 0; i < numHits; i++) {
          const idealPos = i * railLen / numHits;
          const actualPos = Math.floor(idealPos);
          const fractional = idealPos - actualPos;
          const timingOffset = Math.round(fractional * stepDurationMs);

          if (actualPos < railLen) {
            pattern[trackIdx][pageOffset + actualPos] = true;
            timingOffsetMs[trackIdx][pageOffset + actualPos] = timingOffset;
          }
        }
      }
      else if (preset === '5over') {
        // B15: Euclidean 5-over with perfect timing - 5 hits evenly distributed
        for (let i = 0; i < N_STEPS; i++) {
          pattern[trackIdx][pageOffset + i] = false;
        }
        const numHits = 5;
        const stepDurationMs = 125; // Assumes 120 BPM (125ms per 16th note)

        for (let i = 0; i < numHits; i++) {
          const idealPos = i * railLen / numHits;
          const actualPos = Math.floor(idealPos);
          const fractional = idealPos - actualPos;
          const timingOffset = Math.round(fractional * stepDurationMs);

          if (actualPos < railLen) {
            pattern[trackIdx][pageOffset + actualPos] = true;
            timingOffsetMs[trackIdx][pageOffset + actualPos] = timingOffset;
          }
        }
      }
      else if (preset === 'yugen') {
        // B17: Yūgen (幽玄) - Beautiful chaos with randomized ALL parameters
        for (let i = 0; i < N_STEPS; i++) {
          pattern[trackIdx][pageOffset + i] = false;
        }

        const numHits = Math.floor(Math.random() * 8) + 1; // 1-8 hits
        const availableSteps = Array.from({length: railLen}, (_, i) => i);

        // Shuffle and pick first numHits positions
        for (let i = availableSteps.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [availableSteps[i], availableSteps[j]] = [availableSteps[j], availableSteps[i]];
        }

        const pitchOptions = [-12, -7, -3, 0, 3, 7, 12];

        for (let i = 0; i < Math.min(numHits, railLen); i++) {
          const step = availableSteps[i];
          const globalIdx = pageOffset + step;

          // Place the hit
          pattern[trackIdx][globalIdx] = true;

          // B16: Randomize ALL parameters for complete chaos
          // Random interval (1-8)
          if (probability[trackIdx]) {
            probability[trackIdx][globalIdx] = Math.floor(Math.random() * 8) + 1;
          }

          // Random morph target (avoid self)
          if (morphTarget[trackIdx]) {
            let target = Math.floor(Math.random() * NUM_SOUNDS);
            // Avoid morphing to self
            if (target === trackIdx && NUM_SOUNDS > 1) {
              target = (target + 1) % NUM_SOUNDS;
            }
            morphTarget[trackIdx][globalIdx] = target;
          }

          // Random morph amount (0-100)
          if (morphAmt[trackIdx]) {
            morphAmt[trackIdx][globalIdx] = Math.floor(Math.random() * 101);
          }

          // Random timing offset ±50ms
          if (timingOffsetMs[trackIdx]) {
            timingOffsetMs[trackIdx][globalIdx] = Math.floor(Math.random() * 101) - 50;
          }

          // Random pitch shift
          if (stepPitch[trackIdx]) {
            const randomPitch = pitchOptions[Math.floor(Math.random() * pitchOptions.length)];
            stepPitch[trackIdx][globalIdx] = randomPitch;
          }
        }
      }

      // Refresh UI - use refreshGridFromArrays() not buildUI()
      refreshGridFromArrays();

      // Make sure cursor is still in correct position
      if (typeof highlight === 'function') {
        highlight(typeof currentStep !== 'undefined' ? currentStep : 0);
      }

      // Persist changes into current scene
      if (typeof saveGlobalsIntoScene === 'function') {
        saveGlobalsIntoScene(currentPage | 0);  // B10: Fixed - use currentPage not window.currentPage
      }

      // Reset dropdown to placeholder
      e.target.value = '';
    });

    autofillWrap.appendChild(autofillLab);
    autofillWrap.appendChild(autofillSel);

    if (SOUND_NAMES[s] === "Phrases"){
      // A01: Phrase sampler track - Record button and phrase library
      const recBtnRow = document.createElement('div'); recBtnRow.className='btnrow';
      const recBtn = document.createElement('button');
      recBtn.textContent = 'Record (64 beats)';
      recBtn.title = 'Arm recording - will start on next beat 1 and record for 4 bars';
      recBtn.addEventListener('click', ()=>{
        phraseRecArmed = !phraseRecArmed;
        recBtn.textContent = phraseRecArmed ? 'Recording Armed...' : 'Record (64 beats)';
        recBtn.style.backgroundColor = phraseRecArmed ? '#ff6b6b' : '';
      });
      recBtnRow.appendChild(recBtn);

      const phraseInfo = document.createElement('div');
      phraseInfo.className = 'sampleInfo';
      phraseInfo.id = 'phraseInfo';
      phraseInfo.textContent = `${phraseLibrary.length} phrases`;

      sampleCol.appendChild(recBtnRow);
      sampleCol.appendChild(phraseInfo);
      sampleCol.appendChild(volWrap);
      sampleCol.appendChild(panWrap);
    } else if (SOUND_NAMES[s] === "Silencer"){
      // E02: Simplified Silencer row: no sample loader, no sends column, no tone knob, no volume control.
      // E02: Pan controls stereo timing offset - creates rhythmic L/R gate movement
      // Pan left = left channel gates first, right delayed (up to 30ms)
      // Pan right = right channel gates first, left delayed
      // B11: Removed autofillWrap from here - moved to legend (right side)
      sampleCol.appendChild(panWrap);
    } else {
      sampleCol.appendChild(btnrow); sampleCol.appendChild(info);
      // B11: Removed autofillWrap from here - moved to legend (right side)
      sampleCol.appendChild(volWrap);
      sampleCol.appendChild(panWrap);
      // H04: toneWrap removed - Tone dial is injected separately by inject() function

      // G10/G14: Per-track diatonic mode checkbox (Quantize removed in G14)
      const diatonicWrap = document.createElement('label');
      diatonicWrap.className = 'fxToggle';
      diatonicWrap.style.fontSize = '11px';
      diatonicWrap.style.marginTop = '6px'; // G14: Adjusted margin (was 4px when after Quantize)
      diatonicWrap.title = 'Diatonic: Pitch as scale degrees (preserves chord quality). Off: Chromatic semitones (flexible transposition)'; // G13: Add tooltip
      const diatonicCheck = document.createElement('input');
      diatonicCheck.type = 'checkbox';
      diatonicCheck.className = 'diatonicToggle';
      diatonicCheck.checked = diatonicEnabled[s];
      diatonicCheck.addEventListener('change', (e) => {
        diatonicEnabled[s] = e.target.checked;
        // G11: Rebuild pitch dropdown when toggling diatonic mode
        rebuildPitchDropdownsForTrack(s);
      });
      const diatonicLabel = document.createElement('span');
      diatonicLabel.className = 'small';
      diatonicLabel.textContent = 'Diatonic';
      diatonicWrap.appendChild(diatonicCheck);
      diatonicWrap.appendChild(diatonicLabel);
      sampleCol.appendChild(diatonicWrap);
    }

    // G18: Remove .leftCol wrapper - nameAndSends and sampleCol will be appended directly to row

    const steps = document.createElement('div'); steps.className='steps';
    steps.style.setProperty('--rowColor', ROW_TINTS[s]);

    for (let st=0; st<N_STEPS; st++){
      const cell = document.createElement('div'); cell.className='step';
      const btn = document.createElement('button'); btn.className='hit'; btn.dataset.s=s; btn.dataset.st=st;
      btn.addEventListener('click', ()=>{
        // A12: Phrase track is constant across pages - always use steps 0-15
        const globalStep = (s === PHRASES_IDX) ? st : (currentPage * N_STEPS + st);
        pattern[s][globalStep]=!pattern[s][globalStep];
        btn.classList.toggle('active', pattern[s][globalStep]);
      });

      const prob = document.createElement('input'); prob.type = 'range'; prob.min = 1; prob.max = 8;prob.step = 1; prob.value = probability[s][st] || 1;
prob.dataset.param = 'interval'; // B17: Add identifier for refreshGridFromArrays

// Show ×N in the tooltip
prob.title = '×' + prob.value;

prob.addEventListener('input', e => {
  const v = +e.target.value || 1;
  const globalStep = currentPage * N_STEPS + st; // A1: Map to global step
  probability[s][globalStep] = v;

  // Keep tooltip in sync with the slider
  prob.title = '×' + v;
});

      const mSel = document.createElement('select'); mSel.style.width='56px';
      for (let t=0;t<NUM_SOUNDS;t++){ const o=document.createElement('option'); o.value=t; o.textContent=SOUND_NAMES[t]; mSel.appendChild(o); }
      mSel.addEventListener('change', e=>{
        const globalStep = currentPage * N_STEPS + st; // A1: Map to global step
        morphTarget[s][globalStep]=+e.target.value;
      });
      mSel.title='Morph To';

      const mAmt = document.createElement('input'); mAmt.type='range'; mAmt.min=0; mAmt.max=100; mAmt.value=0; mAmt.title='Morph Amount';
      mAmt.addEventListener('input', e=>{
        const globalStep = currentPage * N_STEPS + st; // A1: Map to global step
        morphAmt[s][globalStep]=+e.target.value;
      });

      const tOff = document.createElement('input'); tOff.type='range'; tOff.min=-100; tOff.max=100; tOff.value=0; tOff.step=1; tOff.title='Timing (ms)';
      tOff.addEventListener('input', e=>{
        const globalStep = currentPage * N_STEPS + st; // A1: Map to global step
        timingOffsetMs[s][globalStep]=+e.target.value;
      });

      // G11: Pitch per hit - dynamic dropdown based on diatonic mode
      const pSel = document.createElement('select'); pSel.title='Pitch Shift';
      const globalStep = st; // Store global step for this cell (step within page)
      pSel.innerHTML = generatePitchOptions(s, 0); // s = track index, 0 = default value
      // G18: Set value explicitly (normalized 0→1 for diatonic mode)
      pSel.value = diatonicEnabled[s] ? "1" : "0";

      // G11: Store reference to dropdown for rebuilding
      pitchDropdowns[s][globalStep] = pSel;

      pSel.addEventListener('change', e=>{
        const globalStepIdx = currentPage * N_STEPS + st; // A1: Map to global step
        stepPitch[s][globalStepIdx]=+e.target.value;
      });

      // A01: Phrase track uses phrase selection dropdown instead of normal parameters
      if (SOUND_NAMES[s] === "Phrases") {
        const phraseSel = document.createElement('select');
        phraseSel.style.width = '100%';
        phraseSel.className = 'phraseSelect';
        phraseSel.dataset.step = st;

        // Build options: None + all phrases in library
        const noneOpt = document.createElement('option');
        noneOpt.value = '';
        noneOpt.textContent = '—';
        phraseSel.appendChild(noneOpt);

        for (let i = 0; i < phraseLibrary.length; i++) {
          const opt = document.createElement('option');
          opt.value = i;
          opt.textContent = phraseLibrary[i].name || `Phrase ${i + 1}`;
          phraseSel.appendChild(opt);
        }

        // A12: Phrase track is constant across all pages - always use steps 0-15
        const globalStep = st; // Not page-dependent
        if (phraseAssignments[globalStep] != null) {
          phraseSel.value = phraseAssignments[globalStep];
        }

        phraseSel.addEventListener('change', e => {
          const globalStep = st; // A12: Always reference steps 0-15
          const val = e.target.value;
          phraseAssignments[globalStep] = val === '' ? null : parseInt(val);

          // Clear shuffle when phrase changes
          phraseShufflePatterns[globalStep] = null;
          phraseShuffledBuffers[globalStep] = null;
          phraseActiveMode[globalStep] = null;

          // Update button state
          const remixBtn = cell.querySelector('.remixBtn');
          const chaosBtn = cell.querySelector('.chaosBtn');
          if (remixBtn) {
            remixBtn.disabled = val === '';
            remixBtn.style.boxShadow = '';
          }
          if (chaosBtn) {
            chaosBtn.disabled = val === '';
            chaosBtn.style.boxShadow = '';
          }
        });

        const phraseWrap = document.createElement('div');
        phraseWrap.className = 'ui-row';
        phraseWrap.style.marginTop = '4px';
        phraseWrap.appendChild(phraseSel);

        // Add remix and chaos buttons
        const remixBtn = document.createElement('button');
        remixBtn.className = 'remixBtn';
        remixBtn.textContent = '≋';
        remixBtn.title = 'Remix - Shuffle into 16 slices';
        remixBtn.style.marginTop = '2px';
        remixBtn.style.fontSize = '18px';
        remixBtn.style.padding = '0';
        remixBtn.style.width = '30px';
        remixBtn.style.height = '30px';
        remixBtn.style.minWidth = '30px';
        remixBtn.style.minHeight = '30px';
        remixBtn.style.boxSizing = 'border-box';
        remixBtn.style.backgroundColor = 'transparent';
        remixBtn.style.color = '#999';
        remixBtn.style.border = '1px solid #555';
        remixBtn.style.borderRadius = '4px';
        remixBtn.style.display = 'inline-flex';
        remixBtn.style.alignItems = 'center';
        remixBtn.style.justifyContent = 'center';
        remixBtn.style.cursor = 'pointer';
        remixBtn.style.verticalAlign = 'top';
        remixBtn.disabled = phraseAssignments[st] == null;
        if (phraseActiveMode[st] === 'remix') {
          remixBtn.style.boxShadow = '0 0 0 1px rgba(110, 231, 183, 0.6)';
        }

        remixBtn.addEventListener('click', () => {
          const globalStep = st;
          const phraseIdx = phraseAssignments[globalStep];

          if (phraseIdx == null) return; // No phrase selected

          // Generate remix pattern (16 slices, simple shuffle)
          const sliceOrder = Array.from({length: 16}, (_, i) => i);
          phraseShufflePatterns[globalStep] = {
            mode: 'remix',
            pattern: shuffleArray(sliceOrder),
            reverse: Array(16).fill(false)
          };

          // Clear cached buffer to force regeneration
          phraseShuffledBuffers[globalStep] = null;

          // Set active mode
          phraseActiveMode[globalStep] = 'remix';

          // Update button highlights
          remixBtn.style.boxShadow = '0 0 0 1px rgba(110, 231, 183, 0.6)';
          chaosBtn.style.boxShadow = '';
        });

        const chaosBtn = document.createElement('button');
        chaosBtn.className = 'chaosBtn';
        chaosBtn.textContent = '⚡︎';
        chaosBtn.title = 'Chaos - 32 slices, 25% reverse, 25% repeat';
        chaosBtn.style.marginTop = '2px';
        chaosBtn.style.fontSize = '18px';
        chaosBtn.style.padding = '0';
        chaosBtn.style.width = '30px';
        chaosBtn.style.height = '30px';
        chaosBtn.style.minWidth = '30px';
        chaosBtn.style.minHeight = '30px';
        chaosBtn.style.boxSizing = 'border-box';
        chaosBtn.style.marginLeft = '0px';
        chaosBtn.style.backgroundColor = 'transparent';
        chaosBtn.style.color = '#999';
        chaosBtn.style.border = '1px solid #555';
        chaosBtn.style.borderRadius = '4px';
        chaosBtn.style.display = 'inline-flex';
        chaosBtn.style.alignItems = 'center';
        chaosBtn.style.justifyContent = 'center';
        chaosBtn.style.cursor = 'pointer';
        chaosBtn.style.verticalAlign = 'top';
        chaosBtn.disabled = phraseAssignments[st] == null;
        if (phraseActiveMode[st] === 'chaos') {
          chaosBtn.style.boxShadow = '0 0 0 1px rgba(110, 231, 183, 0.6)';
        }

        chaosBtn.addEventListener('click', () => {
          const globalStep = st;
          const phraseIdx = phraseAssignments[globalStep];

          if (phraseIdx == null) return; // No phrase selected

          // Generate chaos pattern (32 slices with repetition and reverse)
          const pattern = [];
          const reverse = [];

          for (let i = 0; i < 32; i++) {
            // 25% chance to repeat a previous slice, otherwise pick sequentially
            if (Math.random() < 0.25 && pattern.length > 0) {
              // Pick a random slice from the original 32 slices
              pattern.push(Math.floor(Math.random() * 32));
            } else {
              // Pick next slice in shuffled order
              pattern.push(i);
            }

            // 25% chance to reverse this slice
            reverse.push(Math.random() < 0.25);
          }

          // Shuffle the pattern array
          const shuffledPattern = shuffleArray(pattern);

          phraseShufflePatterns[globalStep] = {
            mode: 'chaos',
            pattern: shuffledPattern,
            reverse: reverse
          };

          // Clear cached buffer to force regeneration
          phraseShuffledBuffers[globalStep] = null;

          // Set active mode
          phraseActiveMode[globalStep] = 'chaos';

          // Update button highlights
          chaosBtn.style.boxShadow = '0 0 0 1px rgba(110, 231, 183, 0.6)';
          remixBtn.style.boxShadow = '';
        });

        const shuffleBtnWrap = document.createElement('div');
        shuffleBtnWrap.className = 'ui-row';
        shuffleBtnWrap.style.marginTop = '2px';
        shuffleBtnWrap.appendChild(remixBtn);
        shuffleBtnWrap.appendChild(chaosBtn);

        cell.appendChild(btn);
        cell.appendChild(phraseWrap);
        cell.appendChild(shuffleBtnWrap);
      } else {
        const probWrap = document.createElement('div'); probWrap.className='ui-row'; probWrap.appendChild(prob);
        const selWrap  = document.createElement('div'); selWrap.className='ui-row'; selWrap.appendChild(mSel);
        const amtWrap  = document.createElement('div'); amtWrap.className='ui-row';  amtWrap.appendChild(mAmt);
        const timWrap  = document.createElement('div'); timWrap.className='ui-row';  timWrap.appendChild(tOff);
        const pitchWrap  = document.createElement('div'); pitchWrap.className='ui-row';  pitchWrap.appendChild(pSel);

        cell.appendChild(btn); cell.appendChild(probWrap); cell.appendChild(selWrap); cell.appendChild(amtWrap); cell.appendChild(timWrap); cell.appendChild(pitchWrap);
      }
      steps.appendChild(cell);
    }

    const legend = document.createElement('div'); legend.className='legend';
    const r0 = document.createElement('div'); r0.className='row'; r0.style.height='20px'; // B12: Reduced from 40px to move Autofill up
    // B14: Only add Autofill dropdown for non-Phrases tracks
    if (SOUND_NAMES[s] !== "Phrases") {
      r0.appendChild(autofillWrap);
    }

    // A01: Simplified legend for Phrases track
    if (SOUND_NAMES[s] === "Phrases") {
      const r1 = document.createElement('div'); r1.className='row'; r1.innerHTML = '<span>Phrase</span>';
      legend.append(r0, r1);
    } else {
      const r1 = document.createElement('div'); r1.className='row'; r1.innerHTML = '<span>Interval</span>';
      const r2 = document.createElement('div'); r2.className='row'; r2.innerHTML = '<span>Blend</span>';
      const r3 = document.createElement('div'); r3.className='row'; r3.innerHTML = '<span>Amount</span>';
      const r4 = document.createElement('div'); r4.className='row'; r4.innerHTML = '<span>Timing</span>';
      const r5 = document.createElement('div'); r5.className='row'; r5.innerHTML = '<span>Pitch</span>';
      legend.append(r0,r1,r2,r3,r4,r5);
    }

    // G18: Split ADSR into separate sliders and readout columns
    const adsrSliders = document.createElement('div'); adsrSliders.className='adsrSliders small';
    const adsrReadout = document.createElement('div'); adsrReadout.className='adsrReadout small';
    const isSilencer = (s === SILENCE_IDX);

    // E04: Different HTML structure for Silencer (with readouts) vs others (sliders only)
    if (isSilencer) {
      // E06: Balanced ranges - not too tight, allows silence to work: A:10-50ms, D:10-50ms, S:0-0.40, R:10-40ms
      // Sustain is INVERTED: slider left (0) = loud (0.40), slider right (0.40) = quiet (0)
      // G18: Split into sliders column and readout column
      adsrSliders.innerHTML = `
        <div class="row"><span class="tag">A</span><div class="sliderRow"><input type="range" min="0.010" max="0.050" step="0.001" value="${adsr[s].a}" data-s="${s}" data-p="a"></div></div>
        <div class="row"><span class="tag">D</span><div class="sliderRow"><input type="range" min="0.010" max="0.050" step="0.001" value="${adsr[s].d}" data-s="${s}" data-p="d"></div></div>
        <div class="row"><span class="tag">S</span><div class="sliderRow"><input type="range" min="0" max="0.40" step="0.01" value="${0.40 - adsr[s].s}" data-s="${s}" data-p="s" data-inverted="true"></div></div>
        <div class="row"><span class="tag">R</span><div class="sliderRow"><input type="range" min="0.010" max="0.040" step="0.001" value="${adsr[s].r}" data-s="${s}" data-p="r"></div></div>`;
      adsrReadout.innerHTML = `
        <div class="row readoutValue" data-p="a"></div>
        <div class="row readoutValue" data-p="d"></div>
        <div class="row readoutValue" data-p="s"></div>
        <div class="row readoutValue" data-p="r"></div>`;
    } else {
      // E04: Other tracks: sliders only (no readouts)
      adsrSliders.innerHTML = `
        <div class="row"><span class="tag">A</span><div class="sliderRow"><input type="range" min="0" max="0.3" step="0.001" value="${adsr[s].a}" data-s="${s}" data-p="a"></div></div>
        <div class="row"><span class="tag">D</span><div class="sliderRow"><input type="range" min="0" max="1.2" step="0.01"  value="${adsr[s].d}" data-s="${s}" data-p="d"></div></div>
        <div class="row"><span class="tag">S</span><div class="sliderRow"><input type="range" min="0" max="1"   step="0.01"  value="${adsr[s].s}" data-s="${s}" data-p="s"></div></div>
        <div class="row"><span class="tag">R</span><div class="sliderRow"><input type="range" min="0" max="1.2" step="0.01"  value="${adsr[s].r}" data-s="${s}" data-p="r"></div></div>`;
      adsrReadout.innerHTML = ''; // No readouts for non-Silencer tracks
    }

    // E06/G18: Update ADSR readouts for Silencer (clamp to slider ranges to fix initial display)
    const updateSilencerReadouts = () => {
      if (!isSilencer) return;
      const readouts = adsrReadout.querySelectorAll('.readoutValue'); // G18: Query from new adsrReadout container
      // E06: Clamp to slider ranges: A:10-50ms, D:10-50ms, S:0-0.40, R:10-40ms
      const rawA = adsr[s].a, rawD = adsr[s].d, rawS = adsr[s].s, rawR = adsr[s].r;
      const clampedA = Math.max(0.010, Math.min(0.050, rawA));
      const clampedD = Math.max(0.010, Math.min(0.050, rawD));
      const clampedS = Math.max(0, Math.min(0.40, rawS));
      const clampedR = Math.max(0.010, Math.min(0.040, rawR));
      readouts[0].textContent = `${(clampedA * 1000).toFixed(0)}ms`;
      readouts[1].textContent = `${(clampedD * 1000).toFixed(0)}ms`;
      readouts[2].textContent = `${clampedS.toFixed(2)}`;
      readouts[3].textContent = `${(clampedR * 1000).toFixed(0)}ms`;
    };

    adsrSliders.querySelectorAll('input').forEach(inp=> inp.addEventListener('input', e=>{ // G18: Query from adsrSliders
      const ch=+e.target.dataset.s; const p=e.target.dataset.p;
      // E04: Handle inverted Sustain slider for Silencer (slider left=loud, right=quiet)
      if (e.target.dataset.inverted === 'true') {
        adsr[ch][p] = 0.40 - (+e.target.value); // Invert: slider 0 → sustain 0.40, slider 0.40 → sustain 0
      } else {
        adsr[ch][p] = +e.target.value;
      }
      updateSilencerReadouts(); // E04: Update readouts on change
    }));
    updateSilencerReadouts(); // E04: Initial readout values

    // G18: Append all 6 columns as direct children (no nested containers)
    row.appendChild(nameAndSends);
    row.appendChild(sampleCol);
    row.appendChild(steps);
    row.appendChild(legend);
    if (s !== PHRASES_IDX) {
      row.appendChild(adsrSliders);
      row.appendChild(adsrReadout);
    } else {
      // H01: Add empty placeholders for Phrase Sampler to maintain grid structure
      // Using visibility:hidden (not display:none) to keep elements in grid flow
      const emptyAdsr = document.createElement('div');
      emptyAdsr.className = 'adsrSliders';
      emptyAdsr.style.visibility = 'hidden';
      const emptyReadout = document.createElement('div');
      emptyReadout.className = 'adsrReadout';
      emptyReadout.style.visibility = 'hidden';
      row.appendChild(emptyAdsr);
      row.appendChild(emptyReadout);
    }
    if (!trackLen[s]) trackLen[s] = 16;
    applyTrackLenUI(s);
    buildLenRail(s, steps);
    // Nudge refresh after layout so the marker isn't stuck at 0
    setTimeout(()=>window.dispatchEvent(new Event('resize')), 0);
    grid.appendChild(row);
  }
}

function highlight(idx){
  // ════════════════════════════════════════════════════════════════════════
  // B03: PER-TRACK INDEPENDENT CURSOR LOGIC
  // ════════════════════════════════════════════════════════════════════════
  //
  // This is THE FIX for the 4-month cursor bug.
  //
  // KEY PRINCIPLE: In true polyrhythm, each track is sovereign.
  //   - Track 0 can be on Page 0 while Track 1 is on Page 1 SIMULTANEOUSLY
  //   - Each track shows its cursor based on ITS OWN position
  //   - NO reference track controls all cursors (that was the B01 mistake)
  //
  // HOW IT WORKS:
  //   1. Clear all cursors
  //   2. For EACH track independently:
  //      a. Ask getTrackPosition(ch): "Where is THIS track right now?"
  //      b. If track is on currentPage: Show its cursor at its localStep
  //      c. If track is on another page: Don't show cursor (it's elsewhere)
  //
  // EXAMPLE (viewing Page 0):
  //   Kick:  getTrackPosition(0) → {page: 0, localStep: 5}  → Show cursor at step 5
  //   Snare: getTrackPosition(1) → {page: 1, localStep: 12} → Don't show (on Page 1)
  //   Hat:   getTrackPosition(2) → {page: 0, localStep: 2}  → Show cursor at step 2
  //
  // BROKEN CODE (pre-B03):
  //   - Used playhead[ch] % L (local counter, drifts in chain mode)
  //   - Used ONE reference track to control ALL cursors (B01 mistake)
  //   - Multiple blocks fighting over data-bg attribute
  //   - CSS rule globally hiding cursors based on wrong page calculation
  //
  // FIXED CODE (B03):
  //   - Uses getTrackPosition(ch) per track (audio system's ground truth)
  //   - Each track independent - no reference track tyranny
  //   - No CSS hiding rule - cursor visibility managed per-track in JS
  //   - Single, simple loop - no conflicts
  //
  // ════════════════════════════════════════════════════════════════════════
  try {
    const usingChain = !!window.chainMode && ((pageCount|0) > 1);
    const rows = document.querySelectorAll('.grid .track');
    const Nloc = (typeof N_STEPS !== 'undefined' ? N_STEPS : 16);

    // ────────────────────────────────────────────────────────────────────
    // SINGLE PAGE MODE: Per-track rail-aware highlighting
    // ────────────────────────────────────────────────────────────────────
    // B05 FIX: Even in single-page mode, each track's cursor must respect
    // its rail length. A track with 8-step rail shouldn't show cursor at step 15!
    if (!usingChain) {
      // Use playhead[ch] which already wraps at each track's rail length
      const ph = (window.playheadRef && window.playheadRef.length === rows.length) ? window.playheadRef : null;

      if (ph) {
        rows.forEach((row, ch) => {
          const cells = row.querySelectorAll('.hit');
          const L = Math.max(1, (trackLen && (trackLen[ch]|0)) || Nloc);
          const cursorPos = ph[ch] % L; // Wrap at this track's rail length
          cells.forEach((el, i) => el.classList.toggle('current', i === cursorPos));
        });
      } else if (idx !== -1) {
        // Fallback if playhead not available (shouldn't happen)
        rows.forEach((row, ch) => {
          const cells = row.querySelectorAll('.hit');
          cells.forEach((el,i)=> el.classList.toggle('current', i === (idx%Nloc)));
        });
      }

      const gridEl = document.getElementById('grid');
      if (gridEl) gridEl.setAttribute('data-bg', '0');
      return;
    }

    // ────────────────────────────────────────────────────────────────────
    // CHAIN MODE: Per-Track Independent Cursor Positioning
    // ────────────────────────────────────────────────────────────────────

    // Step 1: Clear all existing cursors
    // (We'll redraw only the ones that belong on this page)
    rows.forEach(row => {
      row.querySelectorAll('.hit.current').forEach(el => el.classList.remove('current'));
    });

    // Step 2: For each track, determine its position and show cursor if on current page
    rows.forEach((row, ch) => {
      // Safety check: Make sure the audio system's positioning function exists
      if (typeof getTrackPosition !== 'function' || typeof trackStepCounter === 'undefined') {
        return;
      }

      // THE KEY: Ask the audio system where THIS specific track is right now
      // getTrackPosition(ch) uses:
      //   - trackStepCounter[ch] (this track's global counter)
      //   - trackLen and scenes data (this track's rail lengths per page)
      //   - Accumulates to find: {page, localStep, globalStep}
      const pos = getTrackPosition(ch);
      const trackPage = pos.page;        // Which page is this track on? (0, 1, 2, ...)
      const localStep = pos.localStep;   // Which step on that page? (0-15)

      // INDEPENDENCE: Only show cursor if THIS track is on the page we're viewing
      // If Kick is on Page 0 and we're viewing Page 0 → Show Kick's cursor
      // If Snare is on Page 1 and we're viewing Page 0 → Don't show Snare's cursor
      // (Snare's cursor will appear when we switch to viewing Page 1)
      if (trackPage === currentPage) {
        const cells = row.querySelectorAll('.hit');
        if (localStep >= 0 && localStep < cells.length) {
          cells[localStep].classList.add('current');
        }
      }
      // else: Track is on another page, don't show cursor here
    });

    // Step 3: Set data-bg attribute for page styling (just a visual hint)
    // We use track 0 (Kick) as reference to determine "active page"
    // But this NO LONGER affects cursor visibility (that's per-track above)
    // It's just for styling the page background to indicate "which page is active"
    const gridEl = document.getElementById('grid');
    if (gridEl && typeof getTrackPosition === 'function') {
      const refPos = getTrackPosition(0);  // Kick as reference
      const isBackground = (refPos.page !== (currentPage|0));
      gridEl.setAttribute('data-bg', isBackground ? '1' : '0');
    }

  } catch(e) {
    console.error('B03 cursor highlight error:', e);
  }
  // ════════════════════════════════════════════════════════════════════════
  // End of highlight() - The fix that took 4 months to find
  // ════════════════════════════════════════════════════════════════════════

};
const startStopBtn = document.getElementById('startStop');
startStopBtn.addEventListener('click', async ()=>{ await toggleTransport(); });
window.addEventListener('keydown', async (e)=>{
  const isSpace = e.code === 'Space' || e.key === ' ';
  const tag = (document.activeElement && document.activeElement.tagName || '').toLowerCase();
  if (!isSpace || tag === 'input' || tag === 'select' || tag === 'textarea') return;
  e.preventDefault();
  await toggleTransport();
});
async function toggleTransport(){
  if (!isPlaying){
    if (audioCtx.state === 'suspended') await audioCtx.resume();
    // A01: Initialize phrase recorder on first play
    if (!phraseRecorderMode) await initPhraseRecorder();
    currentStep = 0; absStep = 0; resetHitCounters(); nextNoteTime = audioCtx.currentTime + lookAhead; // D12: Use scheduler lookahead for correct offset compensation
    // A3: Reset per-track counters and calculate cumulative lengths
    trackStepCounter.fill(0);
    calcCumulativeLengths();
    scheduler(); isPlaying = true; startStopBtn.textContent='Stop';
  } else {
    // B09: Reset to zero on stop
    cancelAnimationFrame(rafId);
    isPlaying=false;
    startStopBtn.textContent='Start';
    currentStep = 0;
    absStep = 0;
    trackStepCounter.fill(0);
    globalBeatCounter = 0; // D11: Reset phrase sampler beat counter for sync
    window.chainPhase = 0; // D11: Reset Link Mode offset for clean restart
    resetPlayheads();
    resetHitCounters();
    highlight(-1);
  }
}

/* Recording UI */
const recordBtn = document.getElementById('recordBtn');
const dlLink = document.getElementById('downloadLink');
recordBtn.addEventListener('click', async ()=>{
  if (audioCtx.state === 'suspended') { try { await audioCtx.resume(); } catch(_){} }
  await ensureRecorder();
  if (!isRecording){
    startWavRecording();
    recordBtn.classList.add('recording'); recordBtn.textContent='Recording WAV';
    dlLink.style.display='none';
  } else {
    // I07: Show processing feedback before encoding
    recordBtn.classList.remove('recording');
    recordBtn.textContent='Processing WAV...';
    recordBtn.disabled = true;

    // Allow UI to update before blocking operation
    await new Promise(resolve => setTimeout(resolve, 50));

    const blob = stopWavRecording();
    const url = URL.createObjectURL(blob);
    dlLink.href = url;
    const now = new Date();
    const y = now.getFullYear();
    const m = String(now.getMonth()+1).padStart(2,'0');
    const d = String(now.getDate()).padStart(2,'0');
    const tempoEl = document.getElementById('tempo');
    const bpm = tempoEl ? tempoEl.value : 120;
    dlLink.download = `sound-tangents-${y}-${m}-${d}_${bpm}bpm.wav`;
    dlLink.textContent = 'Download WAV'; dlLink.style.display='inline';

    // I08: Keep "Processing WAV..." visible briefly after download appears, then revert
    await new Promise(resolve => setTimeout(resolve, 300));
    recordBtn.textContent='Record WAV';
    setTimeout(()=>{ recordBtn.disabled = false; }, 10000);
  }
});

/* Build UI & enable audio */
buildUI();
initScenesUI();
try{ const clr=document.getElementById('clear'); if (clr) clr.addEventListener('click', clearCurrentPage);}catch(_){}
document.body.addEventListener('pointerdown', ()=>{ if (audioCtx.state === 'suspended') audioCtx.resume(); }, {once:true});

/* ===== WAV helpers ===== */
function merge(buffers,len){ const out=new Float32Array(len); let off=0; for(const b of buffers){ out.set(b,off); off+=b.length; } return out; }
function interleave(L,R){ const out=new Float32Array(L.length+R.length); let j=0; for(let i=0;i<L.length;i++){ out[j++]=L[i]; out[j++]=R[i]; } return out; }
function writeStr(view, off, str){ for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i)); }
function floatTo16(view, off, data){ for(let i=0;i<data.length;i++,off+=2){ let s=Math.max(-1,Math.min(1,data[i])); view.setInt16(off, s<0?s*0x8000:s*0x7FFF, true);} }
function encodeWAV(samples, sr, ch){ const buf=new ArrayBuffer(44+samples.length*2); const v=new DataView(buf);
  writeStr(v,0,'RIFF'); v.setUint32(4,36+samples.length*2,true); writeStr(v,8,'WAVE'); writeStr(v,12,'fmt '); v.setUint32(16,16,true);
  v.setUint16(20,1,true); v.setUint16(22,ch,true); v.setUint32(24,sr,true); v.setUint32(28,sr*ch*2,true); v.setUint16(32,ch*2,true); v.setUint16(34,16,true);
  writeStr(v,36,'data'); v.setUint32(40,samples.length*2,true); floatTo16(v,44,samples); return v; }
</script>
<script>
/* === UI1: Inject vertical ADSR column per track (UI only) === */
(function(){
  function makeSlider(min, max, step, value, oninput){
    const inp = document.createElement('input');
    inp.type = 'range'; inp.min = String(min); inp.max = String(max);
    inp.step = String(step); inp.value = String(value);
    inp.addEventListener('input', ()=> oninput(parseFloat(inp.value), inp));
    return inp;
  }
  function ensureAdsrUI(){
    const tracks = document.querySelectorAll('.track');
    if (!tracks.length) return;
    tracks.forEach((tr, sIdx)=>{
      if (typeof PHRASES_IDX !== 'undefined' && sIdx === PHRASES_IDX) return;
      if (tr.querySelector('.adsrSliders')) return; // G19: Check for new .adsrSliders class instead of .adsr
      const col = document.createElement('div'); col.className = 'adsr';
      const rows = [
        ['A', 0.00, 1.00, 0.005, (window.adsr && adsr[sIdx] ? adsr[sIdx].a : 0.02), (v)=>{ if(window.adsr) adsr[sIdx].a = v; }],
        ['D', 0.00, 1.20, 0.005, (window.adsr && adsr[sIdx] ? adsr[sIdx].d : 0.25), (v)=>{ if(window.adsr) adsr[sIdx].d = v; }],
        ['S', 0.00, 1.00, 0.01,  (window.adsr && adsr[sIdx] ? adsr[sIdx].s : 1.00), (v)=>{ if(window.adsr) adsr[sIdx].s = v; }],
        ['R', 0.00, 1.20, 0.005, (window.adsr && adsr[sIdx] ? adsr[sIdx].r : 0.25), (v)=>{ if(window.adsr) adsr[sIdx].r = v; }],
      ];
      rows.forEach(([tag, mn, mx, st, val, onchg])=>{
        const row = document.createElement('div'); row.className='row';
        const lab = document.createElement('div'); lab.className='tag'; lab.textContent = tag;
        const sl = makeSlider(mn, mx, st, val, onchg);
        row.appendChild(lab); row.appendChild(sl);
        col.appendChild(row);
      });
      tr.appendChild(col);
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ()=>{ try{ ensureAdsrUI(); requestAnimationFrame(ensureAdsrUI); }catch(e){} });
  } else {
    try{ ensureAdsrUI(); requestAnimationFrame(ensureAdsrUI); }catch(e){}
  }
})();

</script>


<!-- H11: Removed duplicate Tone Dial IIFE (UI4c) - working version is later in file with inject() -->

<script>
/* === Effect Module Drag-and-Drop Reordering === */
(function(){
  let draggedModule = null;
  let draggedOverModule = null;

  function initEffectDragDrop() {
    const fxContainer = document.querySelector('.fxrow.fxbar');
    if (!fxContainer) return;

    const modules = fxContainer.querySelectorAll('.fxModule');

    modules.forEach(module => {
      const dragHandle = module.querySelector('.fxTitle[draggable="true"]');
      if (!dragHandle) return;

      // Drag start - handle on title, move the module
      dragHandle.addEventListener('dragstart', (e) => {
        draggedModule = module;
        module.style.opacity = '0.4';
        dragHandle.style.cursor = 'grabbing';
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', module.innerHTML);
      });

      // Drag end - on title
      dragHandle.addEventListener('dragend', (e) => {
        module.style.opacity = '1';
        dragHandle.style.cursor = 'grab';
        // Remove all drag-over visual feedback
        modules.forEach(m => {
          m.style.borderColor = '#ff6666';
          m.style.transform = '';
        });
        draggedModule = null;
        draggedOverModule = null;
      });

      // Drag over
      module.addEventListener('dragover', (e) => {
        if (e.preventDefault) {
          e.preventDefault(); // Allows drop
        }
        e.dataTransfer.dropEffect = 'move';

        if (module !== draggedModule) {
          draggedOverModule = module;
          module.style.borderColor = '#66b3ff';
        }

        return false;
      });

      // Drag enter
      module.addEventListener('dragenter', (e) => {
        if (module !== draggedModule) {
          module.style.borderColor = '#66b3ff';
        }
      });

      // Drag leave
      module.addEventListener('dragleave', (e) => {
        if (module !== draggedModule) {
          module.style.borderColor = '#ff6666';
        }
      });

      // Drop
      module.addEventListener('drop', (e) => {
        if (e.stopPropagation) {
          e.stopPropagation(); // Stops browser from redirecting
        }

        if (draggedModule !== module) {
          // Save old order and connections BEFORE moving
          const allModules = Array.from(fxContainer.querySelectorAll('.fxModule'));
          const draggedIndex = allModules.indexOf(draggedModule);
          const targetIndex = allModules.indexOf(module);
          const draggedEffectName = draggedModule.dataset.effect;
          const effectNames = allModules.map(m => m.dataset.effect);

          // Find OLD connections before moving
          const oldPrevIndex = draggedIndex - 1;
          const oldNextIndex = draggedIndex + 1;
          const connectionsToBreak = [];

          if (oldPrevIndex >= 0 && typeof window.connections !== 'undefined') {
            const prevEffect = effectNames[oldPrevIndex];
            if (window.connections[prevEffect]) {
              connectionsToBreak.push({ from: prevEffect, to: draggedEffectName });
            }
          }
          if (oldNextIndex < effectNames.length && typeof window.connections !== 'undefined') {
            if (window.connections[draggedEffectName]) {
              const nextEffect = effectNames[oldNextIndex];
              connectionsToBreak.push({ from: draggedEffectName, to: nextEffect });
            }
          }

          // Reorder the modules
          if (draggedIndex < targetIndex) {
            // Moving right - insert after target
            fxContainer.insertBefore(draggedModule, module.nextSibling);
          } else {
            // Moving left - insert before target
            fxContainer.insertBefore(draggedModule, module);
          }

          // Auto-disconnect the saved connections
          if (typeof window.breakConnections === 'function') {
            window.breakConnections(connectionsToBreak);
          }

          // Update connection dots after reordering
          if (typeof window.updateEffectConnections === 'function') {
            setTimeout(() => window.updateEffectConnections(), 10);
          }
        }

        return false;
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initEffectDragDrop);
  } else {
    initEffectDragDrop();
  }
})();
</script>

<script>
/* === Effect Module Connections === */
(function(){
  let connections = {}; // { effectName: boolean }
  let svgOverlay = null;

  function initEffectConnections() {
    const fxContainer = document.querySelector('.fxrow.fxbar');
    if (!fxContainer) return;

    // Create SVG overlay for connection lines
    if (!svgOverlay) {
      svgOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svgOverlay.style.position = 'absolute';
      svgOverlay.style.top = '0';
      svgOverlay.style.left = '0';
      svgOverlay.style.width = '100%';
      svgOverlay.style.height = '100%';
      svgOverlay.style.pointerEvents = 'none';
      svgOverlay.style.zIndex = '5';
      fxContainer.style.position = 'relative';
      fxContainer.appendChild(svgOverlay);
    }

    updateConnectionDots();
    updateGhostClockState(); // F18: Update Ghost clock state on init
  }

  function updateConnectionDots() {
    const fxContainer = document.querySelector('.fxrow.fxbar');
    if (!fxContainer) return;

    const modules = Array.from(fxContainer.querySelectorAll('.fxModule'));

    // Remove old dots
    fxContainer.querySelectorAll('.fxConnectDot').forEach(dot => dot.remove());

    // Add dots to all modules except the last one
    modules.forEach((module, index) => {
      if (index === modules.length - 1) return; // Skip last module

      const effectName = module.dataset.effect;
      const dot = document.createElement('div');
      dot.className = 'fxConnectDot';
      dot.dataset.effect = effectName;

      if (connections[effectName]) {
        dot.classList.add('connected');
      }

      dot.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleConnection(effectName);
      });

      module.appendChild(dot);
    });

    drawConnectionLines();
  }

  function toggleConnection(effectName) {
    connections[effectName] = !connections[effectName];

    // Update audio routing
    const fxContainer = document.querySelector('.fxrow.fxbar');
    const modules = Array.from(fxContainer.querySelectorAll('.fxModule'));
    const currentIndex = modules.findIndex(m => m.dataset.effect === effectName);

    if (currentIndex >= 0 && currentIndex < modules.length - 1) {
      const nextModule = modules[currentIndex + 1];
      const nextEffectName = nextModule.dataset.effect;

      const sourceSplit = effectSplits[effectName];
      const targetInput = effectInputs[nextEffectName];

      if (connections[effectName]) {
        // Connect: route to next effect
        try {
          sourceSplit.connect(targetInput);
        } catch(e) {
          console.error(`[FX Routing] Error connecting ${effectName} → ${nextEffectName}:`, e);
        }
      } else {
        // Disconnect: remove routing to next effect
        try {
          sourceSplit.disconnect(targetInput);
        } catch(e) {
          console.error(`[FX Routing] Error disconnecting ${effectName} → ${nextEffectName}:`, e);
        }
      }
    }

    updateConnectionDots();
    updateGhostClockState(); // F18: Update Ghost clock dropdown state
  }

  function drawConnectionLines() {
    if (!svgOverlay) return;

    // Clear existing lines
    while (svgOverlay.firstChild) {
      svgOverlay.removeChild(svgOverlay.firstChild);
    }

    const fxContainer = document.querySelector('.fxrow.fxbar');
    const modules = Array.from(fxContainer.querySelectorAll('.fxModule'));
    const containerRect = fxContainer.getBoundingClientRect();

    // H08: Detect CSS transform scale and adjust coordinates
    // getBoundingClientRect returns scaled coords, but SVG draws in unscaled space
    const computedStyle = window.getComputedStyle(fxContainer);
    const transform = computedStyle.transform;
    let scale = 1;
    if (transform && transform !== 'none') {
      const matrix = new DOMMatrix(transform);
      scale = matrix.a; // scaleX from transform matrix
    }

    modules.forEach((module, index) => {
      if (index === modules.length - 1) return;

      const effectName = module.dataset.effect;
      if (!connections[effectName]) return; // Not connected

      const nextModule = modules[index + 1];
      if (!nextModule) return;

      const dot = module.querySelector('.fxConnectDot');
      if (!dot) return;

      const dotRect = dot.getBoundingClientRect();
      const nextModuleRect = nextModule.getBoundingClientRect();

      // H08: Divide by scale to convert from viewport coords to container coords
      const x1 = (dotRect.left - containerRect.left + dotRect.width / 2) / scale;
      const y1 = (dotRect.top - containerRect.top + dotRect.height / 2) / scale;
      const x2 = (nextModuleRect.left - containerRect.left) / scale;
      const y2 = (nextModuleRect.top - containerRect.top + nextModuleRect.height / 2) / scale;

      // Create SVG line
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.setAttribute('class', 'fxConnectionLine');
      svgOverlay.appendChild(line);
    });
  }

  // F18: Update Ghost Clock dropdown state based on connections
  function updateGhostClockState() {
    const clockFooter = document.getElementById('ghostClockFooter');
    if (!clockFooter) return;

    const fxContainer = document.querySelector('.fxrow.fxbar');
    if (!fxContainer) return;

    const modules = Array.from(fxContainer.querySelectorAll('.fxModule'));
    const ghostIndex = modules.findIndex(m => m.dataset.effect === 'ghost');

    if (ghostIndex <= 0) {
      // Ghost is first or not found - no incoming connections possible
      clockFooter.classList.add('inactive');
      return;
    }

    // Check if any effect before Ghost is connected to it
    const prevModule = modules[ghostIndex - 1];
    const prevEffectName = prevModule.dataset.effect;

    if (connections[prevEffectName]) {
      // An effect is connected TO Ghost - activate clock
      clockFooter.classList.remove('inactive');
      if (!ghostClockEnabled && isPlaying) {
        // Just enabled while playing - initialize clock time
        nextGhostClockTime = audioCtx.currentTime;
      }
      ghostClockEnabled = true; // F18: Enable clock triggers
      // F18: Set send amount for channel 4 (Bloom) to enable clock triggers
      if (typeof ghostSendGains !== 'undefined' && ghostSendGains[4]) {
        ghostSendGains[4].gain.value = 0.5; // Medium send for clock triggers
      }
    } else {
      // No effect connected TO Ghost - deactivate clock
      clockFooter.classList.add('inactive');
      ghostClockEnabled = false; // F18: Disable clock triggers
      // F18: Reset send amount for channel 4
      if (typeof ghostSendGains !== 'undefined' && ghostSendGains[4]) {
        ghostSendGains[4].gain.value = 0;
      }
    }
  }

  // Re-draw lines on window resize
  window.addEventListener('resize', drawConnectionLines);

  // Disconnect all connections involving a specific effect
  function disconnectAllConnectionsForModule(effectName) {
    const fxContainer = document.querySelector('.fxrow.fxbar');
    if (!fxContainer) return;

    const modules = Array.from(fxContainer.querySelectorAll('.fxModule'));
    const effectNames = modules.map(m => m.dataset.effect);

    // Find connections TO this effect (from previous module)
    const prevIndex = effectNames.indexOf(effectName) - 1;
    if (prevIndex >= 0) {
      const prevEffectName = effectNames[prevIndex];
      if (connections[prevEffectName]) {
        // Disconnect audio
        try {
          effectSplits[prevEffectName].disconnect(effectInputs[effectName]);
        } catch(e) {}
        // Clear connection state
        connections[prevEffectName] = false;
      }
    }

    // Find connections FROM this effect (to next module)
    if (connections[effectName]) {
      const nextIndex = effectNames.indexOf(effectName) + 1;
      if (nextIndex < effectNames.length) {
        const nextEffectName = effectNames[nextIndex];
        // Disconnect audio
        try {
          effectSplits[effectName].disconnect(effectInputs[nextEffectName]);
        } catch(e) {}
      }
      // Clear connection state
      connections[effectName] = false;
    }
  }

  // Break specific connections (used when moving modules)
  function breakConnections(connectionsToBreak) {
    connectionsToBreak.forEach(({ from, to }) => {
      if (connections[from]) {
        // Disconnect audio
        try {
          effectSplits[from].disconnect(effectInputs[to]);
        } catch(e) {
          console.error(`[FX Routing] Error disconnecting ${from} → ${to}:`, e);
        }
        // Clear connection state
        connections[from] = false;
      }
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initEffectConnections);
  } else {
    initEffectConnections();
  }

  // Expose functions and state
  window.updateEffectConnections = updateConnectionDots;
  window.disconnectAllConnectionsForModule = disconnectAllConnectionsForModule;
  window.breakConnections = breakConnections;
  window.connections = connections; // Expose for drag-drop to check
})();
</script>

<script>
/* === 3i1d: Tone dial DOM upgrade (stack readout under dial) === */
(function(){
  function upgrade(){
    document.querySelectorAll('.toneWrap').forEach(wrap=>{
      if (wrap.querySelector('.toneDialCol')) return; // already upgraded
      const dial = wrap.querySelector('.toneDial');
      const readout = wrap.querySelector('.toneReadout');
      if (!dial || !readout) return;
      const col = document.createElement('div');
      col.className = 'toneDialCol';
      // keep label as first child; insert col right after label (or at end if no label)
      const label = wrap.querySelector('.small');
      if (label && label.parentElement === wrap){
        wrap.insertBefore(col, label.nextSibling);
      } else {
        wrap.appendChild(col);
      }
      col.appendChild(dial);
      col.appendChild(readout);
    });
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', upgrade); }
  else { upgrade(); }
})();
</script>


<script>
/* === UI4e: Tone dial — hard-stops, fixed center during drag, anti-jitter === */
(function(){
  const CHS = window.NUM_SOUNDS || 10; /* E12: Updated from 8 to 10 to include Silencer and Phrases */
  // I10: Always initialize tone dials to Neutral (0) on page load
  // I11: Removed localStorage persistence entirely - tone dials are session-only
  let toneDeg = new Array(CHS).fill(0);
  function clamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }

  function calcMapping(deg){
    const x = deg / 160; const t = Math.abs(x);
    const ease = t*t*(1 - 0.3*(1 - t));
    const lpfHz = 300 + (12000 - 300) * (1 - ease);
    const hpfHz = 40 + (2000 - 40) * ease;
    const Q = 0.8 + 1.2 * ease;
    let mode = 'Neutral', freq = 20000;
    if (x < -0.02){ mode='LPF'; freq=lpfHz; }
    else if (x > 0.02){ mode='HPF'; freq=hpfHz; }
    return {mode, freq, Q};
  }
  function fmtHz(hz){ return hz>=1000 ? (hz/1000).toFixed(hz<1500?2:1)+'k' : Math.round(hz)+' Hz'; }

  
function tryApplyTone(ch){
  const map = calcMapping(toneDeg[ch]);
  const now = (window.audioCtx && audioCtx.currentTime) || 0;

  // Prefer per-track toneLo/toneHi if present in this scope
  try{
    if (typeof toneLo !== 'undefined' && typeof toneHi !== 'undefined' && toneLo[ch] && toneHi[ch]){
      const lo = toneLo[ch], hi = toneHi[ch];
      if (map.mode==='LPF'){
        lo.type='lowpass';
        (lo.Q.setTargetAtTime||((v)=>lo.Q.value=v)).call(lo.Q, map.Q, now, 0.03);
        (lo.frequency.setTargetAtTime||((v)=>lo.frequency.value=v)).call(lo.frequency, map.freq, now, 0.03);
        hi.type='allpass';
        (hi.Q.setTargetAtTime||((v)=>hi.Q.value=v)).call(hi.Q, 0.707, now, 0.03);
        (hi.frequency.setTargetAtTime||((v)=>hi.frequency.value=v)).call(hi.frequency, 20000, now, 0.03);
      } else if (map.mode==='HPF'){
        lo.type='allpass';
        (lo.Q.setTargetAtTime||((v)=>lo.Q.value=v)).call(lo.Q, 0.707, now, 0.03);
        (lo.frequency.setTargetAtTime||((v)=>lo.frequency.value=v)).call(lo.frequency, 20000, now, 0.03);
        hi.type='highpass';
        (hi.Q.setTargetAtTime||((v)=>hi.Q.value=v)).call(hi.Q, map.Q, now, 0.03);
        (hi.frequency.setTargetAtTime||((v)=>hi.frequency.value=v)).call(hi.frequency, map.freq, now, 0.03);
      } else {
        lo.type='allpass'; hi.type='allpass';
        (lo.Q.setTargetAtTime||((v)=>lo.Q.value=v)).call(lo.Q, 0.707, now, 0.03);
        (hi.Q.setTargetAtTime||((v)=>hi.Q.value=v)).call(hi.Q, 0.707, now, 0.03);
        (lo.frequency.setTargetAtTime||((v)=>lo.frequency.value=v)).call(lo.frequency, 20000, now, 0.03);
        (hi.frequency.setTargetAtTime||((v)=>hi.frequency.value=v)).call(hi.frequency, 20000, now, 0.03);
      }
      return map;
    }
  }catch(e){}

  // Fallback: older builds using toneFilter[]
  try{
    if (typeof toneFilter !== 'undefined' && toneFilter[ch]){
      const f = toneFilter[ch];
      if (map.mode==='LPF'){
        f.type='lowpass';
        (f.Q.setTargetAtTime||((v)=>f.Q.value=v)).call(f.Q, map.Q, now, 0.03);
        (f.frequency.setTargetAtTime||((v)=>f.frequency.value=v)).call(f.frequency, map.freq, now, 0.03);
      } else if (map.mode==='HPF'){
        f.type='highpass';
        (f.Q.setTargetAtTime||((v)=>f.Q.value=v)).call(f.Q, map.Q, now, 0.03);
        (f.frequency.setTargetAtTime||((v)=>f.frequency.value=v)).call(f.frequency, map.freq, now, 0.03);
      } else {
        f.type='allpass';
        (f.Q.setTargetAtTime||((v)=>f.Q.value=v)).call(f.Q, 0.707, now, 0.03);
        (f.frequency.setTargetAtTime||((v)=>f.frequency.value=v)).call(f.frequency, 20000, now, 0.03);
      }
      return map;
    }
  }catch(e){}

  return map;
}

  function setDialDeg(dialEl, deg){ dialEl.style.setProperty('--deg', deg + 'deg'); }

  function degFromPoint(cx, cy, clientX, clientY, prevDeg){
    let rad = Math.atan2(clientY - cy, clientX - cx) - Math.PI/2;
    let deg = rad * 180/Math.PI;
    if (deg > 180) deg -= 360;
    if (deg < -180) deg += 360;
    deg = clamp(deg, -160, 160);
    if (typeof prevDeg === 'number'){
      const delta = deg - prevDeg;
      if (delta > 120) deg = -160;
      else if (delta < -120) deg = 160;
    }
    return deg;
  }

  function updateReadout(col, ch){
    const rd = col.querySelector('.toneReadout'); if (!rd) return;
    const map = calcMapping(toneDeg[ch]);
    rd.textContent = (map.mode==='Neutral') ? 'Neutral' : (map.mode+' '+fmtHz(map.freq));
  }

  function wireOneDial(dial){
    const ch = +dial.dataset.ch;
    const col = dial.closest('.toneDialCol') || dial.parentElement;

    let cx = null, cy = null, prevDeg = toneDeg[ch];
    let rafId = null, pending = null;

    function applyPending(){
      rafId = null;
      if (!pending) return;
      const {deg} = pending; pending = null;
      toneDeg[ch]=deg; setDialDeg(dial, deg); tryApplyTone(ch); updateReadout(col, ch);
    }

    function move(ev){
      const p = (ev.touches? ev.touches[0] : ev);
      const d = degFromPoint(cx, cy, p.clientX, p.clientY, prevDeg);
      prevDeg = d;
      pending = {deg:d};
      if (!rafId) rafId = requestAnimationFrame(applyPending);
    }

    function up(){
      window.removeEventListener('pointermove', move);
      window.removeEventListener('pointerup', up);
      window.removeEventListener('touchmove', move);
      window.removeEventListener('touchend', up);
      if (rafId) { cancelAnimationFrame(rafId); rafId=null; applyPending(); }
    }

    dial.addEventListener('pointerdown', (e)=>{
      const r = dial.getBoundingClientRect();
      cx = r.left + r.width/2; cy = r.top + r.height/2; prevDeg = toneDeg[ch];
      move(e);
      window.addEventListener('pointermove', move);
      window.addEventListener('pointerup', up, {once:true});
    });

    dial.addEventListener('touchstart', (e)=>{
      e.preventDefault();
      const r = dial.getBoundingClientRect();
      cx = r.left + r.width/2; cy = r.top + r.height/2; prevDeg = toneDeg[ch];
      move(e);
      window.addEventListener('touchmove', move);
      window.addEventListener('touchend', up, {once:true});
    }, {passive:false});

    dial.addEventListener('dblclick', ()=>{ toneDeg[ch]=0; prevDeg=0; setDialDeg(dial,0); tryApplyTone(ch); updateReadout(col,ch); });

    dial.addEventListener('wheel', (e)=>{
      e.preventDefault();
      const step = e.shiftKey ? 1 : 4;
      let d = clamp(toneDeg[ch] + (e.deltaY > 0 ? -step : step), -160, 160);
      if (Math.abs(d) < 4) d = 0;
      toneDeg[ch] = prevDeg = d; setDialDeg(dial,d); tryApplyTone(ch); updateReadout(col,ch);
    }, {passive:false});

    dial.tabIndex = 0; dial.setAttribute('role','slider'); dial.setAttribute('aria-label','Tone');
    dial.addEventListener('keydown', (e)=>{
      let handled = true; const step = e.shiftKey ? 1 : 4;
      if (e.key==='ArrowLeft'){ toneDeg[ch] = clamp(toneDeg[ch]-step, -160, 160); }
      else if (e.key==='ArrowRight'){ toneDeg[ch] = clamp(toneDeg[ch]+step, -160, 160); }
      else if (e.key==='Home'){ toneDeg[ch] = 0; }
      else handled = false;
      if (handled){ e.preventDefault(); let d = toneDeg[ch]; if (Math.abs(d) < 4) d = toneDeg[ch]=0; prevDeg=d;
        setDialDeg(dial,d); tryApplyTone(ch); updateReadout(col,ch); }
    });

    setDialDeg(dial, toneDeg[ch]); updateReadout(col, ch); tryApplyTone(ch);
  }

  function inject(){
    const tracks = document.querySelectorAll('.track');
    tracks.forEach((tr, idx)=>{
      const silenceIdx = SOUND_NAMES.indexOf("Silencer");
      if (idx === silenceIdx) return;

      let host = tr.querySelector('.sampleCol') || tr.querySelector('.leftCol') || tr;
      if (tr.querySelector('.toneDial')) return;

      const toneWrap  = document.createElement('div'); toneWrap.className = 'toneWrap';
      const toneLabel = document.createElement('div'); toneLabel.className='small'; toneLabel.textContent='Tone';

      const dialCol = document.createElement('div'); dialCol.className='toneDialCol';
      const dial = document.createElement('div'); dial.className='toneDial'; dial.dataset.ch=String(idx);
      dial.title = 'Tone: LPF ← 12 o’clock → HPF (double-click resets; Shift+Wheel = fine)';
      const needle = document.createElement('div'); needle.className='toneNeedle'; dial.appendChild(needle);
      const readout = document.createElement('div'); readout.className='toneReadout'; readout.textContent='Neutral';

      dialCol.appendChild(dial); dialCol.appendChild(readout);
      toneWrap.appendChild(toneLabel); toneWrap.appendChild(dialCol);
      host.appendChild(toneWrap);
      wireOneDial(dial);
    });
  }

  function boot(){
    inject();
    const grid = document.getElementById('grid') || document.body;
    const mo = new MutationObserver(()=>inject());
    mo.observe(grid, {childList:true, subtree:true});
    let n=0; const iv = setInterval(()=>{ inject(); if (++n>10) clearInterval(iv); }, 300);
  }

  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', boot); }
  else { boot(); }
})();
</script>
<script>
// HUM UI late binding - now simplified (no IR rebuild, no convolver crossfade)
// Main bindings are in earlier section; this just ensures initialization on late load
(function bindHumUI_Safe(){
  const $ = (id)=>document.getElementById(id);
  function wired(){ return typeof humIn !== 'undefined' && typeof humWet !== 'undefined'; }
  function bind(){
    if (!wired()) return; // safety check
    // Ensure params are applied once on load
    try{ if (typeof applyHumParams === 'function') applyHumParams(); }catch(_){}
  }

  if (document.readyState === 'complete') {
    setTimeout(bind, 0);
  } else {
    window.addEventListener('load', ()=>setTimeout(bind, 0), { once:true });
  }
})();


</script>

<!-- Browser compatibility detection -->
<script>
(function () {
  const ua = navigator.userAgent;

  // Safari detection (exclude Chrome/Chromium/Edge on all platforms)
  const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  const isWebKit = /AppleWebKit/.test(ua);
  const isChrome = /Chrome|Chromium/.test(ua);
  const isEdge = /Edg/.test(ua);
  const isSafari = isWebKit && /Safari/.test(ua) && !isChrome && !isEdge;

  const isMobileish = isIOS || window.matchMedia('(max-width: 900px)').matches || window.matchMedia('(pointer: coarse)').matches;

  const needsWarning = isSafari || isMobileish;
  if (!needsWarning) return;

  const overlay = document.getElementById('compat-overlay');
  const body = document.getElementById('compat-body');
  const cont = document.getElementById('compat-continue');

  // Message
  const lines = [];
  if (isSafari) {
    lines.push(`<p><strong>Safari isn't supported right now.</strong> The audio engine doesn't work properly in Safari—you'll experience constant audio glitches and some features will cause complete audio failure.</p>`);
  }
  if (isMobileish) {
    lines.push(`<p><strong>Mobile devices aren't supported.</strong> This app is designed for desktop/laptop with full audio interface support.</p>`);
  }
  lines.push(`<p>Please use a supported desktop browser:</p>
    <ul>
      <li>Firefox (recommended)</li>
      <li>Chrome</li>
    </ul>`);

  body.innerHTML = lines.join('');

  // Show overlay
  overlay.style.display = 'flex';

  cont.addEventListener('click', () => {
    overlay.style.display = 'none';
  });
})();
</script>

<!-- H09: Removed debug width indicators script -->

</body>
</html>



